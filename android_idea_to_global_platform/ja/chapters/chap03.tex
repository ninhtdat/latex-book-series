\chapter{Kiến trúc kỹ thuật cốt lõi của Android}
\ruby{Android}{あんどろいど}の\ruby{中核}{ちゅうかく}\ruby{技術}{ぎじゅつ}\ruby{アーキテクチャ}{あーきてくちゃ}

Android không chỉ là một hệ điều hành di động phổ biến, mà còn là một nền tảng phần mềm được thiết kế với tư duy kỹ thuật rõ ràng và mang tính chiến lược dài hạn. Đối với kỹ sư CNTT, việc hiểu kiến trúc Android không dừng ở mức “các lớp thành phần”, mà quan trọng hơn là nắm được vai trò, ranh giới trách nhiệm và lý do tồn tại của từng lớp trong toàn bộ hệ thống. Kiến trúc này cho phép Android vận hành ổn định trên hàng tỷ thiết bị với cấu hình phần cứng rất khác nhau, đồng thời vẫn đảm bảo hiệu năng, bảo mật và khả năng mở rộng.
Androidは\ruby{単}{たん}なる\ruby{普及}{ふきゅう}した\ruby{モバイル}{もばいる}\ruby{OS}{おーえす}ではなく、\ruby{明確}{めいかく}な\ruby{技術的}{ぎじゅつてき}\ruby{思想}{しそう}と\ruby{長期的}{ちょうきてき}な\ruby{戦略}{せんりゃく}に\ruby{基}{もと}づいて\ruby{設計}{せっけい}された\ruby{ソフトウェア}{そふとうぇあ}\ruby{プラットフォーム}{ぷらっとふぉーむ}である。\ruby{IT}{あいてぃー}\ruby{技術者}{ぎじゅつしゃ}にとって、Androidの\ruby{アーキテクチャ}{あーきてくちゃ}を\ruby{理解}{りかい}するとは、\ruby{単}{たん}に\ruby{層}{そう}\ruby{構造}{こうぞう}を\ruby{把握}{はあく}することではなく、\ruby{各}{かく}\ruby{層}{そう}の\ruby{役割}{やくわり}、\ruby{責任}{せきにん}\ruby{範囲}{はんい}、および\ruby{存在}{そんざい}\ruby{理由}{りゆう}を\ruby{体系的}{たいけいてき}に\ruby{理解}{りかい}することを\ruby{意味}{いみ}する。この\ruby{アーキテクチャ}{あーきてくちゃ}により、Androidは\ruby{多様}{たよう}な\ruby{ハードウェア}{はーどうぇあ}\ruby{構成}{こうせい}を\ruby{持}{も}つ\ruby{数十億}{すうじゅうおく}の\ruby{端末}{たんまつ}上で\ruby{安定}{あんてい}して\ruby{動作}{どうさ}しつつ、\ruby{性能}{せいのう}、\ruby{安全性}{あんぜんせい}、および\ruby{拡張性}{かくちょうせい}を\ruby{同時}{どうじ}に\ruby{確保}{かくほ}している。

Trong các lớp kiến trúc của Android, Linux Kernel đóng vai trò nền tảng, quyết định trực tiếp đến độ ổn định, khả năng quản lý tài nguyên và mức độ an toàn của toàn bộ hệ điều hành. Việc Android lựa chọn Linux Kernel không phải là quyết định mang tính tình thế, mà là một lựa chọn chiến lược, ảnh hưởng sâu rộng đến toàn bộ hệ sinh thái Android sau này.
Androidの\ruby{アーキテクチャ}{あーきてくちゃ}における\ruby{各}{かく}\ruby{層}{そう}の\ruby{中}{なか}で、Linux Kernelは\ruby{基盤}{きばん}としての\ruby{役割}{やくわり}を\ruby{担}{にな}い、\ruby{安定性}{あんていせい}、\ruby{資源}{しげん}\ruby{管理}{かんり}\ruby{能力}{のうりょく}、および\ruby{安全性}{あんぜんせい}を\ruby{直接}{ちょくせつ}に\ruby{左右}{さゆう}する。AndroidがLinux Kernelを\ruby{採用}{さいよう}したのは\ruby{一時的}{いちじてき}な\ruby{判断}{はんだん}ではなく、\ruby{将来}{しょうらい}の\ruby{エコシステム}{えこしすてむ}に\ruby{深}{ふか}い\ruby{影響}{えいきょう}を\ruby{及}{およ}ぼす\ruby{戦略的}{せんりゃくてき}\ruby{選択}{せんたく}であった。

\section{Linux Kernel}
Linux Kernel

Linux Kernel là lớp thấp nhất trong kiến trúc Android và đóng vai trò như “hệ điều hành lõi” thực sự. Mọi thành phần phía trên, từ Android Runtime đến Framework và ứng dụng, đều gián tiếp phụ thuộc vào các cơ chế mà kernel cung cấp. Android không sử dụng Linux Kernel một cách nguyên bản, mà có các tùy chỉnh để phù hợp với môi trường thiết bị di động, tuy nhiên các chức năng cốt lõi của kernel vẫn được giữ nguyên.
Linux KernelはAndroid\ruby{アーキテクチャ}{あーきてくちゃ}における\ruby{最下層}{さいかそう}であり、\ruby{実質的}{じっしつてき}な\ruby{中核}{ちゅうかく}\ruby{OS}{おーえす}として\ruby{機能}{きのう}する。Android Runtime、Framework、そして\ruby{アプリケーション}{あぷりけーしょん}に\ruby{至}{いた}るまで、\ruby{上位}{じょうい}の\ruby{全}{すべ}ての\ruby{構成}{こうせい}\ruby{要素}{ようそ}は、kernelが\ruby{提供}{ていきょう}する\ruby{仕組}{しく}みに\ruby{間接的}{かんせつてき}に\ruby{依存}{いぞん}している。AndroidはLinux Kernelを\ruby{完全}{かんぜん}に\ruby{原型}{げんけい}のまま\ruby{使用}{しよう}しているわけではなく、\ruby{モバイル}{もばいる}\ruby{環境}{かんきょう}に\ruby{適合}{てきごう}させるための\ruby{調整}{ちょうせい}が\ruby{加}{くわ}えられているが、kernelの\ruby{中核的}{ちゅうかくてき}\ruby{機能}{きのう}は\ruby{維持}{いじ}されている。

Trước hết, Linux Kernel chịu trách nhiệm quản lý tiến trình. Mỗi ứng dụng Android chạy trong một tiến trình riêng biệt, với một không gian địa chỉ độc lập. Kernel đảm nhiệm việc lập lịch CPU, phân chia thời gian xử lý giữa các tiến trình, cũng như chuyển đổi ngữ cảnh khi cần thiết. Cách tiếp cận này giúp Android tận dụng trực tiếp cơ chế đa nhiệm đã được kiểm chứng của Linux, đồng thời tạo nền tảng cho mô hình cách ly ứng dụng, vốn là yêu cầu bắt buộc trong môi trường di động nhiều rủi ro bảo mật.
まず、Linux Kernelは\ruby{プロセス}{ぷろせす}\ruby{管理}{かんり}を\ruby{担当}{たんとう}する。Androidの\ruby{各}{かく}\ruby{アプリケーション}{あぷりけーしょん}は\ruby{独立}{どくりつ}した\ruby{プロセス}{ぷろせす}として\ruby{実行}{じっこう}され、\ruby{個別}{こべつ}の\ruby{アドレス}{あどれす}\ruby{空間}{くうかん}を\ruby{持}{も}つ。kernelはCPUの\ruby{スケジューリング}{すけじゅーりんぐ}、\ruby{処理}{しょり}\ruby{時間}{じかん}の\ruby{分配}{ぶんぱい}、および\ruby{文脈}{ぶんみゃく}\ruby{切替}{きりかえ}を\ruby{管理}{かんり}する。この\ruby{方式}{ほうしき}により、AndroidはLinuxで\ruby{実証}{じっしょう}されてきた\ruby{マルチタスク}{まるちたすく}\ruby{機構}{きこう}を\ruby{直接}{ちょくせつ}\ruby{活用}{かつよう}でき、\ruby{高}{たか}い\ruby{セキュリティ}{せきゅりてぃ}\ruby{リスク}{りすく}を\ruby{伴}{ともな}う\ruby{モバイル}{もばいる}\ruby{環境}{かんきょう}に\ruby{不可欠}{ふかけつ}な\ruby{アプリケーション}{あぷりけーしょん}\ruby{分離}{ぶんり}\ruby{モデル}{もでる}の\ruby{基盤}{きばん}が\ruby{形成}{けいせい}される。

Bên cạnh quản lý tiến trình, quản lý bộ nhớ là một nhiệm vụ then chốt của Linux Kernel trong Android. Kernel cung cấp cơ chế bộ nhớ ảo, cho phép mỗi tiến trình “nhìn thấy” một không gian bộ nhớ riêng, trong khi thực tế bộ nhớ vật lý được chia sẻ và quản lý tập trung. Trên các thiết bị có tài nguyên hạn chế như điện thoại di động, việc kiểm soát bộ nhớ hiệu quả là yếu tố sống còn. Android bổ sung thêm các cơ chế như low memory killer daemon (LMKD) để phối hợp với kernel trong việc chủ động giải phóng tài nguyên khi hệ thống rơi vào trạng thái thiếu bộ nhớ.
\ruby{プロセス}{ぷろせす}\ruby{管理}{かんり}に\ruby{加}{くわ}え、\ruby{メモリ}{めもり}\ruby{管理}{かんり}もAndroidにおけるLinux Kernelの\ruby{中核的}{ちゅうかくてき}\ruby{任務}{にんむ}である。kernelは\ruby{仮想}{かそう}\ruby{メモリ}{めもり}\ruby{機構}{きこう}を\ruby{提供}{ていきょう}し、\ruby{各}{かく}\ruby{プロセス}{ぷろせす}に\ruby{独自}{どくじ}の\ruby{メモリ}{めもり}\ruby{空間}{くうかん}を\ruby{認識}{にんしき}させる\ruby{一方}{いっぽう}で、\ruby{物理}{ぶつり}\ruby{メモリ}{めもり}は\ruby{集中的}{しゅうちゅうてき}に\ruby{管理}{かんり}される。\ruby{携帯}{けいたい}\ruby{電話}{でんわ}のような\ruby{資源}{しげん}が\ruby{限}{かぎ}られた\ruby{端末}{たんまつ}では、\ruby{効率的}{こうりつてき}な\ruby{メモリ}{めもり}\ruby{制御}{せいぎょ}が\ruby{致命的}{ちめいてき}に\ruby{重要}{じゅうよう}である。Androidはlow memory killer daemon（LMKD）などの\ruby{仕組}{しく}みを\ruby{追加}{ついか}し、kernelと\ruby{連携}{れんけい}して\ruby{メモリ}{めもり}\ruby{不足}{ふそく}\ruby{状態}{じょうたい}に\ruby{陥}{おちい}った\ruby{際}{さい}に\ruby{資源}{しげん}を\ruby{能動的}{のうどうてき}に\ruby{解放}{かいほう}する。

Linux Kernel cũng là nơi quản lý toàn bộ hệ thống driver. Tất cả các thành phần phần cứng như màn hình, camera, âm thanh, cảm biến, Wi-Fi hay Bluetooth đều được điều khiển thông qua driver chạy trong không gian kernel. Việc đặt driver ở tầng kernel giúp đảm bảo hiệu năng cao và khả năng truy cập trực tiếp phần cứng, đồng thời cho phép các lớp phía trên tương tác với phần cứng theo cách thống nhất, thông qua các giao diện đã được trừu tượng hóa.
Linux Kernelは\ruby{全}{すべ}ての\ruby{ドライバ}{どらいば}\ruby{管理}{かんり}も\ruby{担}{にな}う。\ruby{画面}{がめん}、\ruby{カメラ}{かめら}、\ruby{音声}{おんせい}、\ruby{センサー}{せんさー}、Wi-Fi、Bluetoothなどの\ruby{ハードウェア}{はーどうぇあ}は、kernel\ruby{空間}{くうかん}で\ruby{動作}{どうさ}する\ruby{ドライバ}{どらいば}を\ruby{通}{とお}じて\ruby{制御}{せいぎょ}される。driverをkernel\ruby{層}{そう}に\ruby{配置}{はいち}することで、\ruby{高}{たか}い\ruby{性能}{せいのう}と\ruby{直接的}{ちょくせつてき}な\ruby{ハードウェア}{はーどうぇあ}\ruby{アクセス}{あくせす}が\ruby{保証}{ほしょう}されるとともに、\ruby{上位}{じょうい}\ruby{層}{そう}が\ruby{抽象化}{ちゅうしょうか}された\ruby{インターフェース}{いんたーふぇーす}を\ruby{通}{とお}じて\ruby{一貫}{いっかん}した\ruby{方法}{ほうほう}で\ruby{ハードウェア}{はーどうぇあ}と\ruby{相互作用}{そうごさよう}できる。

Một khía cạnh quan trọng khác là tính ổn định và độ tin cậy của hệ thống. Linux Kernel đã trải qua hàng chục năm phát triển, được kiểm thử trong nhiều môi trường khác nhau, từ máy chủ, hệ thống nhúng đến thiết bị cá nhân. Android kế thừa trực tiếp sự ổn định này, thay vì phải xây dựng một kernel mới từ đầu. Khi kernel gặp lỗi nghiêm trọng, cơ chế phân tách tiến trình và không gian bộ nhớ giúp hạn chế phạm vi ảnh hưởng, tránh việc toàn bộ hệ thống bị sập chỉ vì lỗi của một ứng dụng.
\ruby{安定性}{あんていせい}と\ruby{信頼性}{しんらいせい}も\ruby{重要}{じゅうよう}な\ruby{側面}{そくめん}である。Linux Kernelは\ruby{数十年}{すうじゅうねん}に\ruby{及}{およ}ぶ\ruby{開発}{かいはつ}の\ruby{歴史}{れきし}を\ruby{持}{も}ち、\ruby{サーバー}{さーばー}、\ruby{組}{く}み\ruby{込}{こ}み\ruby{システム}{しすてむ}、\ruby{個人}{こじん}\ruby{端末}{たんまつ}など\ruby{多様}{たよう}な\ruby{環境}{かんきょう}で\ruby{検証}{けんしょう}されてきた。Androidは\ruby{新}{あら}たにkernelを\ruby{一}{いち}から\ruby{開発}{かいはつ}することなく、この\ruby{安定性}{あんていせい}を\ruby{直接}{ちょくせつ}\ruby{継承}{けいしょう}している。kernelに\ruby{重大}{じゅうだい}な\ruby{障害}{しょうがい}が\ruby{発生}{はっせい}した\ruby{場合}{ばあい}でも、\ruby{プロセス}{ぷろせす}と\ruby{メモリ}{めもり}\ruby{空間}{くうかん}の\ruby{分離}{ぶんり}により、\ruby{影響}{えいきょう}\ruby{範囲}{はんい}が\ruby{限定}{げんてい}され、\ruby{単一}{たんいつ}の\ruby{アプリケーション}{あぷりけーしょん}の\ruby{不具合}{ふぐあい}によって\ruby{全体}{ぜんたい}が\ruby{停止}{ていし}することを\ruby{防}{ふせ}ぐ。

Về bảo mật, Linux Kernel đóng vai trò nền tảng cho mô hình an toàn của Android. Mỗi ứng dụng được gán một UID riêng, chạy trong sandbox độc lập. Kernel chịu trách nhiệm thực thi các quyền truy cập tài nguyên ở mức thấp nhất, ngăn chặn ứng dụng truy cập trái phép vào bộ nhớ, file hệ thống hay tài nguyên của ứng dụng khác. Ngoài ra, Android còn tích hợp SELinux ở chế độ enforcing để áp đặt các chính sách kiểm soát truy cập bắt buộc, tăng cường khả năng phòng vệ trước các lỗ hổng zero-day.
\ruby{セキュリティ}{せきゅりてぃ}の\ruby{観点}{かんてん}では、Linux KernelがAndroidの\ruby{安全}{あんぜん}\ruby{モデル}{もでる}の\ruby{基盤}{きばん}となる。\ruby{各}{かく}\ruby{アプリケーション}{あぷりけーしょん}には\ruby{固有}{こゆう}のUIDが\ruby{割}{わ}り\ruby{当}{あ}てられ、\ruby{独立}{どくりつ}した\ruby{サンドボックス}{さんどぼっくす}で\ruby{実行}{じっこう}される。kernelは\ruby{最低}{さいてい}\ruby{レベル}{れべる}で\ruby{資源}{しげん}\ruby{アクセス}{あくせす}の\ruby{制御}{せいぎょ}を\ruby{実施}{じっし}し、\ruby{不正}{ふせい}な\ruby{メモリ}{めもり}、\ruby{システム}{しすてむ}\ruby{ファイル}{ふぁいる}、または\ruby{他}{ほか}の\ruby{アプリケーション}{あぷりけーしょん}\ruby{資源}{しげん}への\ruby{アクセス}{あくせす}を\ruby{防止}{ぼうし}する。さらに、AndroidはSELinuxを\ruby{強制}{きょうせい}\ruby{モード}{もーど}で\ruby{統合}{とうごう}し、\ruby{必須}{ひっす}の\ruby{アクセス}{あくせす}\ruby{制御}{せいぎょ}\ruby{ポリシー}{ぽりしー}を\ruby{適用}{てきよう}することで、\ruby{ゼロデイ}{ぜろでい}\ruby{脆弱性}{ぜいじゃくせい}に\ruby{対}{たい}する\ruby{防御}{ぼうぎょ}\ruby{能力}{のうりょく}を\ruby{強化}{きょうか}している。

Từ góc nhìn chiến lược, việc lựa chọn Linux Kernel mang lại cho Android ba lợi thế lớn. Thứ nhất, Android có thể tận dụng trực tiếp cộng đồng mã nguồn mở khổng lồ của Linux, bao gồm các bản vá bảo mật, cải tiến hiệu năng và hỗ trợ phần cứng mới. Thứ hai, các nhà sản xuất thiết bị vốn đã quen thuộc với Linux có thể dễ dàng tích hợp Android vào sản phẩm của mình. Thứ ba, Android tránh được rủi ro kỹ thuật và chi phí khổng lồ nếu phải tự phát triển và duy trì một kernel riêng.
\ruby{戦略的}{せんりゃくてき}\ruby{視点}{してん}から見ると、Linux Kernelの\ruby{採用}{さいよう}はAndroidに\ruby{三}{さん}つの\ruby{大}{おお}きな\ruby{利点}{りてん}を\ruby{もたら}{もたら}した。\ruby{第一}{だいいち}に、Androidは\ruby{巨大}{きょだい}なLinuxの\ruby{オープンソース}{おーぷんそーす}\ruby{コミュニティ}{こみゅにてぃ}を\ruby{直接}{ちょくせつ}\ruby{活用}{かつよう}でき、\ruby{セキュリティ}{せきゅりてぃ}\ruby{修正}{しゅうせい}、\ruby{性能}{せいのう}\ruby{改善}{かいぜん}、および\ruby{新}{あたら}しい\ruby{ハードウェア}{はーどうぇあ}\ruby{対応}{たいおう}の\ruby{恩恵}{おんけい}を\ruby{受}{う}けられる。\ruby{第二}{だいに}に、Linuxに\ruby{精通}{せいつう}した\ruby{端末}{たんまつ}\ruby{メーカー}{めーかー}は、Androidを\ruby{比較的}{ひかくてき}\ruby{容易}{ようい}に\ruby{製品}{せいひん}へ\ruby{統合}{とうごう}できる。\ruby{第三}{だいさん}に、Androidは\ruby{独自}{どくじ}のkernelを\ruby{開発}{かいはつ}・\ruby{維持}{いじ}する\ruby{場合}{ばあい}に\ruby{想定}{そうてい}される\ruby{技術的}{ぎじゅつてき}\ruby{リスク}{りすく}と\ruby{莫大}{ばくだい}な\ruby{コスト}{こすと}を\ruby{回避}{かいひ}できた。

Tóm lại, Linux Kernel không chỉ là một lớp kỹ thuật trong kiến trúc Android, mà là nền móng quyết định đến hiệu năng, độ ổn định và tính an toàn của toàn bộ hệ điều hành. Mọi lớp phía trên đều được xây dựng với giả định rằng kernel cung cấp một môi trường thực thi đáng tin cậy, hiệu quả và có khả năng mở rộng lâu dài.
\ruby{要約}{ようやく}すると、Linux KernelはAndroid\ruby{アーキテクチャ}{あーきてくちゃ}における\ruby{単}{たん}なる\ruby{技術}{ぎじゅつ}\ruby{層}{そう}ではなく、\ruby{性能}{せいのう}、\ruby{安定性}{あんていせい}、および\ruby{安全性}{あんぜんせい}を\ruby{左右}{さゆう}する\ruby{基盤}{きばん}そのものである。\ruby{上位}{じょうい}の\ruby{全}{すべ}ての\ruby{層}{そう}は、kernelが\ruby{信頼}{しんらい}できる\ruby{実行}{じっこう}\ruby{環境}{かんきょう}を\ruby{提供}{ていきょう}し、\ruby{長期的}{ちょうきてき}に\ruby{拡張}{かくちょう}可能であるという\ruby{前提}{ぜんてい}の\ruby{下}{もと}で\ruby{構築}{こうちく}されている。

\section{Hardware Abstraction Layer (HAL)}
\ruby{ハードウェア}{はーどうぇあ}\ruby{抽象}{ちゅうしょう}\ruby{化}{か}\ruby{層}{そう}（HAL）

Hardware Abstraction Layer (HAL) là lớp nằm giữa Linux Kernel và Android Framework, có nhiệm vụ trừu tượng hóa phần cứng và cung cấp các giao diện chuẩn để phần mềm hệ thống có thể truy cập tài nguyên phần cứng mà không phụ thuộc vào chi tiết triển khai cụ thể. Từ góc nhìn kỹ thuật, HAL là lời giải trực tiếp cho bài toán phân mảnh phần cứng – vấn đề mang tính sống còn đối với một hệ điều hành được triển khai trên hàng nghìn mẫu thiết bị khác nhau.

Hardware Abstraction Layer（HAL）は、Linux KernelとAndroid Frameworkの\ruby{間}{あいだ}に\ruby{位置}{いち}する\ruby{層}{そう}であり、\ruby{ハードウェア}{はーどうぇあ}を\ruby{抽象}{ちゅうしょう}\ruby{化}{か}し、\ruby{システム}{しすてむ}\ruby{ソフトウェア}{そふとうぇあ}が\ruby{具体}{ぐたい}\ruby{的}{てき}な\ruby{実装}{じっそう}\ruby{詳細}{しょうさい}に\ruby{依存}{いぞん}することなく、\ruby{ハードウェア}{はーどうぇあ}\ruby{資源}{しげん}へ\ruby{アクセス}{あくせす}できる\ruby{標準}{ひょうじゅん}\ruby{インターフェース}{いんたーふぇーす}を\ruby{提供}{ていきょう}する\ruby{役割}{やくわり}を\ruby{担}{にな}う。\ruby{技術}{ぎじゅつ}\ruby{的}{てき}な\ruby{観点}{かんてん}から\ruby{見}{み}れば、HALは\ruby{ハードウェア}{はーどうぇあ}の\ruby{分断}{ぶんだん}という\ruby{課題}{かだい}に\ruby{対}{たい}する\ruby{直接}{ちょくせつ}的な\ruby{解決}{かいけつ}\ruby{策}{さく}であり、\ruby{数千}{すうせん}に\ruby{及}{およ}ぶ\ruby{異}{こと}なる\ruby{端末}{たんまつ}\ruby{モデル}{もでる}に\ruby{展開}{てんかい}される\ruby{オペレーティング}{おぺれーてぃんぐ}\ruby{システム}{しすてむ}にとって、\ruby{不可欠}{ふかけつ}な\ruby{要素}{ようそ}である。

Trong Android, mỗi loại phần cứng quan trọng đều có một HAL tương ứng, ví dụ như Camera HAL, Audio HAL, Sensor HAL hay Bluetooth HAL. Mỗi HAL định nghĩa một tập các hàm và cấu trúc dữ liệu chuẩn mà Android Framework có thể gọi. Phần triển khai cụ thể của các hàm này do nhà sản xuất thiết bị (OEM) hoặc nhà cung cấp chipset đảm nhiệm, dựa trên đặc điểm phần cứng thực tế. Nhờ đó, Framework chỉ làm việc với “hợp đồng” kỹ thuật đã được chuẩn hóa, thay vì phải xử lý trực tiếp sự khác biệt giữa các chip hay bo mạch.

Androidでは、\ruby{重要}{じゅうよう}な\ruby{ハードウェア}{はーどうぇあ}の\ruby{種類}{しゅるい}ごとに\ruby{対応}{たいおう}するHALが\ruby{用意}{ようい}されており、Camera HAL、Audio HAL、Sensor HAL、Bluetooth HALなどが\ruby{例}{れい}として\ruby{挙}{あ}げられる。\ruby{各}{かく}HALは、Android Frameworkが\ruby{呼}{よ}び\ruby{出}{だ}すことのできる\ruby{関数}{かんすう}や\ruby{データ}{でーた}\ruby{構造}{こうぞう}の\ruby{標準}{ひょうじゅん}\ruby{的}{てき}な\ruby{集合}{しゅうごう}を\ruby{定義}{ていぎ}する。これらの\ruby{関数}{かんすう}の\ruby{具体}{ぐたい}\ruby{的}{てき}な\ruby{実装}{じっそう}は、\ruby{端末}{たんまつ}\ruby{製造}{せいぞう}\ruby{業者}{ぎょうしゃ}（OEM）や\ruby{チップセット}{ちっぷせっと}\ruby{提供}{ていきょう}\ruby{者}{しゃ}が、\ruby{実際}{じっさい}の\ruby{ハードウェア}{はーどうぇあ}の\ruby{特性}{とくせい}に\ruby{基}{もと}づいて\ruby{担}{にな}う。これによりFrameworkは、\ruby{チップ}{ちっぷ}や\ruby{基板}{きばん}ごとの差異を\ruby{直接}{ちょくせつ}\ruby{処理}{しょり}することなく、\ruby{標準}{ひょうじゅん}\ruby{化}{か}された\ruby{技術}{ぎじゅつ}\ruby{的}{てき}な「\ruby{契約}{けいやく}」のみに\ruby{基}{もと}づいて\ruby{動作}{どうさ}する。

Về mặt kiến trúc, HAL đóng vai trò như một ranh giới kỹ thuật rõ ràng. Phía dưới HAL là kernel và driver, gắn chặt với phần cứng cụ thể. Phía trên HAL là Android Framework, nơi logic hệ điều hành và API cho lập trình viên được triển khai. Ranh giới này giúp giảm sự phụ thuộc chặt chẽ (tight coupling) giữa các lớp, từ đó tăng khả năng bảo trì và mở rộng hệ thống. Khi một thành phần phần cứng được thay thế hoặc nâng cấp, nhà sản xuất chỉ cần cập nhật HAL tương ứng, trong khi phần còn lại của hệ điều hành có thể giữ nguyên.

\ruby{アーキテクチャ}{あーきてくちゃ}の\ruby{観点}{かんてん}では、HALは\ruby{明確}{めいかく}な\ruby{技術}{ぎじゅつ}\ruby{的}{てき}\ruby{境界}{きょうかい}として\ruby{機能}{きのう}する。HALの\ruby{下位}{かい}には、\ruby{特定}{とくてい}の\ruby{ハードウェア}{はーどうぇあ}と\ruby{密接}{みっせつ}に\ruby{結}{むす}び\ruby{付}{つ}いたkernelやdriverが\ruby{存在}{そんざい}し、HALの\ruby{上位}{じょうい}には、\ruby{オペレーティング}{おぺれーてぃんぐ}\ruby{システム}{しすてむ}の\ruby{ロジック}{ろじっく}や\ruby{開発}{かいはつ}\ruby{者}{しゃ}\ruby{向}{む}けAPIが\ruby{実装}{じっそう}されるAndroid Frameworkが\ruby{位置}{いち}する。この\ruby{境界}{きょうかい}により、\ruby{層}{そう}\ruby{間}{かん}の\ruby{強}{つよ}い\ruby{依存}{いぞん}が\ruby{緩和}{かんわ}され、\ruby{保守}{ほしゅ}や\ruby{拡張}{かくちょう}の\ruby{容易}{ようい}さが\ruby{向上}{こうじょう}する。\ruby{ハードウェア}{はーどうぇあ}\ruby{部品}{ぶひん}が\ruby{交換}{こうかん}または\ruby{更新}{こうしん}された\ruby{場合}{ばあい}でも、\ruby{製造}{せいぞう}\ruby{業者}{ぎょうしゃ}は\ruby{対応}{たいおう}するHALのみを\ruby{更新}{こうしん}すれば\ruby{よ}{よ}く、\ruby{他}{ほか}の\ruby{オペレーティング}{おぺれーてぃんぐ}\ruby{システム}{しすてむ}の\ruby{部分}{ぶぶん}は\ruby{維持}{いじ}できる。

Một điểm quan trọng khác của HAL là khả năng hỗ trợ phát triển song song. Google có thể tiếp tục phát triển Android Framework và các phiên bản hệ điều hành mới, trong khi các nhà sản xuất phần cứng phát triển HAL cho thiết bị của họ dựa trên các đặc tả đã công bố. Cách tiếp cận này giúp rút ngắn thời gian đưa sản phẩm ra thị trường, đồng thời giảm xung đột giữa các bên tham gia vào chuỗi giá trị của Android.

HALの\ruby{別}{べつ}の\ruby{重要}{じゅうよう}な\ruby{特徴}{とくちょう}は、\ruby{並行}{へいこう}\ruby{開発}{かいはつ}を\ruby{可能}{かのう}にする\ruby{点}{てん}である。GoogleはAndroid Frameworkや\ruby{新}{あたら}しい\ruby{オペレーティング}{おぺれーてぃんぐ}\ruby{システム}{しすてむ}\ruby{版本}{ばんぽん}の\ruby{開発}{かいはつ}を\ruby{継続}{けいぞく}できる\ruby{一方}{いっぽう}で、\ruby{ハードウェア}{はーどうぇあ}\ruby{製造}{せいぞう}\ruby{業者}{ぎょうしゃ}は\ruby{公開}{こうかい}された\ruby{仕様}{しよう}に\ruby{基}{もと}づき、自社\ruby{端末}{たんまつ}向けのHALを\ruby{開発}{かいはつ}できる。この\ruby{手法}{しゅほう}は、\ruby{製品}{せいひん}の\ruby{市場}{しじょう}\ruby{投入}{とうにゅう}までの\ruby{期間}{きかん}を\ruby{短縮}{たんしゅく}し、Androidの\ruby{価値}{かち}\ruby{連鎖}{れんさ}に\ruby{関与}{かんよ}する\ruby{各}{かく}\ruby{主体}{しゅたい}\ruby{間}{かん}の\ruby{衝突}{しょうとつ}を\ruby{低減}{ていげん}する。

Từ Android 8.0 trở đi, Google giới thiệu khái niệm Treble, trong đó HAL được chuẩn hóa và tách biệt mạnh mẽ hơn thông qua các giao diện ổn định. Điều này cho phép cập nhật phiên bản Android mới mà không yêu cầu thay đổi toàn bộ phần mềm tầng thấp do OEM cung cấp. Về bản chất, Treble không tạo ra HAL, mà khai thác triệt để vai trò vốn có của HAL như một lớp cách ly giữa phần cứng và phần mềm hệ thống.

Android 8.0\ruby{以降}{いこう}、GoogleはTrebleという\ruby{概念}{がいねん}を\ruby{導入}{どうにゅう}し、\ruby{安定}{あんてい}した\ruby{インターフェース}{いんたーふぇーす}を\ruby{通}{つう}じてHALの\ruby{標準}{ひょうじゅん}\ruby{化}{か}と\ruby{分離}{ぶんり}を\ruby{一層}{いっそう}\ruby{強化}{きょうか}した。これにより、OEMが\ruby{提供}{ていきょう}する\ruby{低}{てい}\ruby{層}{そう}\ruby{ソフトウェア}{そふとうぇあ}を\ruby{全面}{ぜんめん}的に\ruby{変更}{へんこう}することなく、\ruby{新}{あたら}しいAndroid\ruby{版本}{ばんぽん}への\ruby{更新}{こうしん}が\ruby{可能}{かのう}となった。\ruby{本質}{ほんしつ}\ruby{的}{てき}には、TrebleはHALを\ruby{新}{あら}たに\ruby{生}{う}み\ruby{出}{だ}したものではなく、\ruby{ハードウェア}{はーどうぇあ}と\ruby{システム}{しすてむ}\ruby{ソフトウェア}{そふとうぇあ}の\ruby{間}{あいだ}における\ruby{隔離}{かくり}\ruby{層}{そう}としてのHALの\ruby{役割}{やくわり}を\ruby{最大限}{さいだいげん}に\ruby{活用}{かつよう}したものである。

Về hiệu năng, HAL được thiết kế để giảm thiểu chi phí trung gian. Các lời gọi từ Framework xuống HAL thường là các lời gọi native, tránh overhead không cần thiết. Điều này đặc biệt quan trọng với các thành phần nhạy cảm về hiệu năng như camera hay audio, nơi độ trễ nhỏ cũng có thể ảnh hưởng trực tiếp đến trải nghiệm người dùng.

\ruby{性能}{せいのう}の\ruby{観点}{かんてん}では、HALは\ruby{中間}{ちゅうかん}\ruby{コスト}{こすと}を\ruby{最小}{さいしょう}\ruby{化}{か}するよう\ruby{設計}{せっけい}されている。FrameworkからHALへの\ruby{呼}{よ}び\ruby{出}{だ}しは、\ruby{多}{おお}くの\ruby{場合}{ばあい}native\ruby{呼}{よ}び\ruby{出}{だ}しであり、\ruby{不要}{ふよう}なoverheadを\ruby{回避}{かいひ}する。これは、cameraやaudioのような\ruby{性能}{せいのう}に\ruby{敏感}{びんかん}な\ruby{構成}{こうせい}\ruby{要素}{ようそ}において、\ruby{僅}{わず}かな\ruby{遅延}{ちえん}であっても\ruby{利用}{りよう}\ruby{者}{しゃ}\ruby{体験}{たいけん}に\ruby{直接}{ちょくせつ}\ruby{影響}{えいきょう}するため、\ruby{特}{とく}に\ruby{重要}{じゅうよう}である。

Xét trên phương diện chiến lược, HAL cho phép Android duy trì một nền tảng phần mềm thống nhất trong khi vẫn hỗ trợ sự đa dạng gần như không giới hạn của phần cứng. Đây là yếu tố then chốt giúp Android mở rộng nhanh chóng trên thị trường toàn cầu. Không có HAL, mỗi biến thể phần cứng mới sẽ kéo theo những thay đổi sâu rộng ở tầng Framework và ứng dụng, khiến hệ sinh thái trở nên khó kiểm soát và tốn kém chi phí bảo trì.

\ruby{戦略}{せんりゃく}\ruby{的}{てき}な\ruby{観点}{かんてん}から\ruby{見}{み}ると、HALはAndroidが\ruby{統一}{とういつ}された\ruby{ソフトウェア}{そふとうぇあ}\ruby{基盤}{きばん}を\ruby{維持}{いじ}しつつ、\ruby{事実}{じじつ}\ruby{上}{じょう}\ruby{無制限}{むせいげん}に\ruby{近}{ちか}い\ruby{ハードウェア}{はーどうぇあ}の\ruby{多様}{たよう}\ruby{性}{せい}を\ruby{支援}{しえん}することを\ruby{可能}{かのう}にする。これは、Androidが\ruby{世界}{せかい}\ruby{市場}{しじょう}で\ruby{急速}{きゅうそく}に\ruby{拡大}{かくだい}するための\ruby{鍵}{かぎ}となる\ruby{要因}{よういん}である。HALが\ruby{存在}{そんざい}しなければ、\ruby{新}{あたら}しい\ruby{ハードウェア}{はーどうぇあ}\ruby{変種}{へんしゅ}ごとにFrameworkや\ruby{アプリケーション}{あぷりけーしょん}\ruby{層}{そう}への\ruby{大規模}{だいきぼ}な\ruby{変更}{へんこう}が\ruby{必要}{ひつよう}となり、\ruby{エコシステム}{えこしすてむ}は\ruby{管理}{かんり}が\ruby{困難}{こんなん}で、\ruby{保守}{ほしゅ}\ruby{コスト}{こすと}も\ruby{増大}{ぞうだい}する。

Tóm lại, Hardware Abstraction Layer không chỉ là một lớp kỹ thuật trung gian, mà là một quyết định kiến trúc mang tính chiến lược. HAL giúp Android cân bằng giữa tính mở, khả năng mở rộng và yêu cầu ổn định lâu dài, đồng thời tạo điều kiện để nhiều bên cùng tham gia phát triển hệ sinh thái mà không phá vỡ cấu trúc tổng thể của hệ điều hành.

\ruby{総括}{そうかつ}すると、Hardware Abstraction Layerは\ruby{単}{たん}なる\ruby{技術}{ぎじゅつ}\ruby{的}{てき}な\ruby{中間}{ちゅうかん}\ruby{層}{そう}ではなく、\ruby{戦略}{せんりゃく}\ruby{的}{てき}な\ruby{アーキテクチャ}{あーきてくちゃ}\ruby{判断}{はんだん}である。HALは、Androidに\ruby{開放}{かいほう}\ruby{性}{せい}、\ruby{拡張}{かくちょう}\ruby{性}{せい}、および\ruby{長期}{ちょうき}\ruby{的}{てき}な\ruby{安定}{あんてい}\ruby{性}{せい}の\ruby{均衡}{きんこう}を\ruby{与}{あた}え、\ruby{複数}{ふくすう}の\ruby{主体}{しゅたい}が\ruby{システム}{しすてむ}の\ruby{全体}{ぜんたい}\ruby{構造}{こうぞう}を\ruby{損}{そこ}なうことなく\ruby{エコシステム}{えこしすてむ}の\ruby{発展}{はってん}に\ruby{参加}{さんか}できる\ruby{環境}{かんきょう}を\ruby{実現}{じつげん}している。

\section{Android Runtime}
\ruby{Android}{あんどろいど}\ruby{Runtime}{らんたいむ}

Android Runtime là môi trường chịu trách nhiệm thực thi mã ứng dụng Android. Không giống các hệ điều hành truyền thống, nơi ứng dụng thường được biên dịch trực tiếp thành mã máy và chạy thẳng trên hệ điều hành, Android lựa chọn một mô hình trung gian: ứng dụng được viết bằng Java hoặc Kotlin, biên dịch thành bytecode, sau đó được thực thi trong một runtime chuyên biệt. Quyết định này phản ánh rõ định hướng của Android trong việc cân bằng giữa tính linh hoạt, khả năng kiểm soát và hiệu năng.

\ruby{Android}{あんどろいど}\ruby{Runtime}{らんたいむ}は、\ruby{Android}{あんどろいど}\ruby{アプリケーション}{あぷりけーしょん}の\ruby{コード}{こーど}を\ruby{実行}{じっこう}する\ruby{環境}{かんきょう}である。\ruby{従来}{じゅうらい}の\ruby{オペレーティング}{おぺれーてぃんぐ}\ruby{システム}{しすてむ}では、\ruby{アプリケーション}{あぷりけーしょん}は\ruby{直接}{ちょくせつ}\ruby{機械}{きかい}\ruby{語}{ご}に\ruby{コンパイル}{こんぱいる}され、\ruby{OS}{おーえす}上で\ruby{実行}{じっこう}されることが\ruby{一般的}{いっぱんてき}である。これに\ruby{対}{たい}し、\ruby{Android}{あんどろいど}は\ruby{中間}{ちゅうかん}\ruby{モデル}{もでる}を\ruby{採用}{さいよう}している。すなわち、\ruby{Java}{じゃば}または\ruby{Kotlin}{ことりん}で\ruby{記述}{きじゅつ}された\ruby{アプリケーション}{あぷりけーしょん}は\ruby{バイト}{ばいと}\ruby{コード}{こーど}に\ruby{変換}{へんかん}され、\ruby{専用}{せんよう}の\ruby{Runtime}{らんたいむ}で\ruby{実行}{じっこう}される。この\ruby{選択}{せんたく}は、\ruby{柔軟性}{じゅうなんせい}、\ruby{制御性}{せいぎょせい}、および\ruby{性能}{せいのう}の\ruby{均衡}{きんこう}を\ruby{重視}{じゅうし}する\ruby{Android}{あんどろいど}の\ruby{方針}{ほうしん}を\ruby{明確}{めいかく}に\ruby{示}{しめ}している。

Trong các phiên bản Android đầu tiên, môi trường thực thi là Dalvik Virtual Machine. Dalvik được thiết kế riêng cho thiết bị di động, khác với Java Virtual Machine truyền thống vốn hướng tới máy tính để bàn và máy chủ. Một đặc điểm kỹ thuật quan trọng của Dalvik là kiến trúc dựa trên thanh ghi (register-based), thay vì dựa trên ngăn xếp (stack-based) như JVM. Cách tiếp cận này giúp giảm số lượng lệnh cần thiết khi thực thi bytecode, từ đó tiết kiệm CPU và năng lượng – yếu tố đặc biệt quan trọng trên thiết bị di động.

\ruby{初期}{しょき}の\ruby{Android}{あんどろいど}\ruby{バージョン}{ばーじょん}では、\ruby{実行}{じっこう}\ruby{環境}{かんきょう}として\ruby{Dalvik}{だるゔぃっく}\ruby{仮想}{かそう}\ruby{マシン}{ましん}が\ruby{採用}{さいよう}されていた。\ruby{Dalvik}{だるゔぃっく}は\ruby{モバイル}{もばいる}\ruby{端末}{たんまつ}向けに\ruby{設計}{せっけい}されており、\ruby{デスクトップ}{ですくとっぷ}や\ruby{サーバ}{さーば}を\ruby{対象}{たいしょう}とする\ruby{従来}{じゅうらい}の\ruby{Java}{じゃば}\ruby{仮想}{かそう}\ruby{マシン}{ましん}とは\ruby{異}{こと}なる。Dalvikの\ruby{重要}{じゅうよう}な\ruby{技術的}{ぎじゅつてき}\ruby{特徴}{とくちょう}は、\ruby{スタック}{すたっく}\ruby{ベース}{べーす}のJVMとは\ruby{異}{こと}なり、\ruby{レジスタ}{れじすた}\ruby{ベース}{べーす}の\ruby{アーキテクチャ}{あーきてくちゃ}を\ruby{採用}{さいよう}している\ruby{点}{てん}である。この\ruby{方式}{ほうしき}により、\ruby{バイト}{ばいと}\ruby{コード}{こーど}\ruby{実行}{じっこう}に\ruby{必要}{ひつよう}な\ruby{命令}{めいれい}\ruby{数}{すう}が\ruby{削減}{さくげん}され、\ruby{CPU}{しーぴーゆー}および\ruby{電力}{でんりょく}の\ruby{消費}{しょうひ}を\ruby{抑制}{よくせい}できる。これは\ruby{モバイル}{もばいる}\ruby{端末}{たんまつ}において\ruby{特}{とく}に\ruby{重要}{じゅうよう}な\ruby{要素}{ようそ}である。

Dalvik sử dụng định dạng bytecode riêng là DEX (Dalvik Executable), được tối ưu để nhiều lớp (class) có thể dùng chung hằng số và dữ liệu, giảm kích thước bộ nhớ. Ở giai đoạn đầu, Dalvik chủ yếu dựa vào cơ chế JIT (Just-In-Time Compilation), tức là mã bytecode được biên dịch sang mã máy ngay trong quá trình chạy. Cách làm này giúp giảm thời gian cài đặt ứng dụng và tiết kiệm dung lượng lưu trữ, nhưng đánh đổi bằng hiệu năng không ổn định và mức tiêu thụ CPU cao tại thời điểm runtime.

Dalvikは、\ruby{DEX}{でっくす}（Dalvik Executable）と\ruby{呼}{よ}ばれる\ruby{独自}{どくじ}の\ruby{バイト}{ばいと}\ruby{コード}{こーど}\ruby{形式}{けいしき}を\ruby{使用}{しよう}し、\ruby{複数}{ふくすう}の\ruby{クラス}{くらす}が\ruby{定数}{ていすう}や\ruby{データ}{でーた}を\ruby{共有}{きょうゆう}できるよう\ruby{最適化}{さいてきか}されている。これにより、\ruby{メモリ}{めもり}\ruby{サイズ}{さいず}が\ruby{削減}{さくげん}される。\ruby{初期}{しょき}の\ruby{段階}{だんかい}では、Dalvikは\ruby{主}{おも}に\ruby{JIT}{じぇいあいてぃー}（Just-In-Time Compilation）に\ruby{依存}{いぞん}していた。すなわち、\ruby{バイト}{ばいと}\ruby{コード}{こーど}は\ruby{実行}{じっこう}\ruby{時}{じ}に\ruby{機械}{きかい}\ruby{語}{ご}へ\ruby{コンパイル}{こんぱいる}される。この\ruby{方式}{ほうしき}は\ruby{インストール}{いんすとーる}\ruby{時間}{じかん}の\ruby{短縮}{たんしゅく}や\ruby{ストレージ}{すとれーじ}\ruby{使用}{しよう}\ruby{量}{りょう}の\ruby{削減}{さくげん}に\ruby{寄与}{きよ}するが、\ruby{性能}{せいのう}の\ruby{不安定}{ふあんてい}さや\ruby{Runtime}{らんたいむ}\ruby{時}{じ}における\ruby{CPU}{しーぴーゆー}\ruby{負荷}{ふか}の\ruby{増大}{ぞうだい}という\ruby{代償}{だいしょう}を\ruby{伴}{ともな}った。

Những hạn chế này dần bộc lộ khi ứng dụng Android ngày càng phức tạp. Từ Android 5.0, Google giới thiệu Android Runtime (ART) để thay thế hoàn toàn Dalvik. Sự thay đổi cốt lõi của ART là chuyển từ JIT sang AOT (Ahead-Of-Time Compilation). Thay vì biên dịch khi chạy, ART biên dịch bytecode thành mã máy ngay trong quá trình cài đặt ứng dụng. Kết quả là ứng dụng khởi động nhanh hơn, thực thi ổn định hơn và giảm tải cho CPU trong quá trình sử dụng.

これらの\ruby{制約}{せいやく}は、\ruby{Android}{あんどろいど}\ruby{アプリケーション}{あぷりけーしょん}が\ruby{高度化}{こうどか}するにつれて\ruby{顕在化}{けんざいか}した。そこで\ruby{Android}{あんどろいど}5.0以降、\ruby{Google}{ぐーぐる}は\ruby{Dalvik}{だるゔぃっく}を\ruby{完全}{かんぜん}に\ruby{置}{お}き\ruby{換}{か}える\ruby{Android}{あんどろいど}\ruby{Runtime}{らんたいむ}（ART）を\ruby{導入}{どうにゅう}した。ARTの\ruby{中核}{ちゅうかく}的\ruby{変化}{へんか}は、\ruby{JIT}{じぇいあいてぃー}から\ruby{AOT}{えーおーてぃー}（Ahead-Of-Time Compilation）への\ruby{移行}{いこう}である。ARTでは、\ruby{実行}{じっこう}\ruby{時}{じ}ではなく、\ruby{アプリケーション}{あぷりけーしょん}\ruby{インストール}{いんすとーる}\ruby{時}{じ}に\ruby{バイト}{ばいと}\ruby{コード}{こーど}を\ruby{機械}{きかい}\ruby{語}{ご}へ\ruby{コンパイル}{こんぱいる}する。その\ruby{結果}{けっか}、\ruby{起動}{きどう}\ruby{速度}{そくど}が\ruby{向上}{こうじょう}し、\ruby{実行}{じっこう}は\ruby{安定}{あんてい}し、\ruby{利用}{りよう}\ruby{中}{ちゅう}の\ruby{CPU}{しーぴーゆー}\ruby{負荷}{ふか}が\ruby{軽減}{けいげん}された。

Từ góc nhìn quản lý bộ nhớ, ART mang lại những cải tiến đáng kể. Cơ chế garbage collection được thiết kế lại để giảm thời gian dừng (pause time), hạn chế hiện tượng giật, lag khi ứng dụng đang chạy. ART cũng cung cấp các công cụ profiling và debugging tốt hơn, giúp lập trình viên và hệ thống theo dõi hành vi bộ nhớ một cách chính xác hơn. Điều này không chỉ cải thiện trải nghiệm người dùng, mà còn nâng cao chất lượng phát triển ứng dụng trong toàn bộ hệ sinh thái.

\ruby{メモリ}{めもり}\ruby{管理}{かんり}の\ruby{観点}{かんてん}からも、ARTは\ruby{大}{おお}きな\ruby{改善}{かいぜん}を\ruby{もたら}{もたら}した。\ruby{ガーベジ}{がーべじ}\ruby{コレクション}{これくしょん}の\ruby{仕組}{しく}みは\ruby{再設計}{さいせっけい}され、\ruby{停止}{ていし}\ruby{時間}{じかん}（pause time）が\ruby{短縮}{たんしゅく}されることで、\ruby{アプリケーション}{あぷりけーしょん}\ruby{実行}{じっこう}\ruby{中}{ちゅう}の\ruby{カクツキ}{かくつき}や\ruby{遅延}{ちえん}が\ruby{抑}{おさ}えられた。さらにARTは、\ruby{プロファイリング}{ぷろふぁいりんぐ}や\ruby{デバッグ}{でばっぐ}の\ruby{ため}{ため}の\ruby{高度}{こうど}な\ruby{ツール}{つーる}を\ruby{提供}{ていきょう}し、\ruby{プログラマー}{ぷろぐらまー}や\ruby{システム}{しすてむ}が\ruby{メモリ}{めもり}\ruby{挙動}{きょどう}をより\ruby{正確}{せいかく}に\ruby{把握}{はあく}できるようにした。これは\ruby{利用者}{りようしゃ}\ruby{体験}{たいけん}の\ruby{向上}{こうじょう}に\ruby{寄与}{きよ}するだけでなく、\ruby{生態系}{せいたいけい}\ruby{全体}{ぜんたい}における\ruby{開発}{かいはつ}\ruby{品質}{ひんしつ}の\ruby{向上}{こうじょう}にも\ruby{貢献}{こうけん}した。

Một điểm quan trọng khác là mô hình “mỗi ứng dụng một runtime instance”. Mỗi ứng dụng Android chạy trong một tiến trình riêng, với một instance ART riêng biệt. Cách tổ chức này, kết hợp với sandbox ở mức Linux Kernel, tạo nên một lớp cách ly vững chắc giữa các ứng dụng. Nếu một runtime gặp lỗi nghiêm trọng, ảnh hưởng sẽ bị giới hạn trong phạm vi ứng dụng đó, thay vì lan sang toàn bộ hệ thống.

もう一つの\ruby{重要}{じゅうよう}な\ruby{点}{てん}は、「\ruby{一}{いち}\ruby{アプリケーション}{あぷりけーしょん}\ruby{一}{いち}\ruby{Runtime}{らんたいむ}」という\ruby{モデル}{もでる}である。各\ruby{Android}{あんどろいど}\ruby{アプリケーション}{あぷりけーしょん}は\ruby{独立}{どくりつ}した\ruby{プロセス}{ぷろせす}で\ruby{実行}{じっこう}され、それぞれ\ruby{専用}{せんよう}のART\ruby{インスタンス}{いんすたんす}を\ruby{持}{も}つ。この\ruby{構成}{こうせい}は、\ruby{Linux}{りなっくす}\ruby{カーネル}{かーねる}\ruby{レベル}{れべる}の\ruby{サンドボックス}{さんどぼっくす}と\ruby{組}{く}み\ruby{合}{あ}わさることで、\ruby{アプリケーション}{あぷりけーしょん}\ruby{間}{かん}に\ruby{強固}{きょうこ}な\ruby{分離}{ぶんり}を\ruby{実現}{じつげん}する。あるRuntimeに\ruby{重大}{じゅうだい}な\ruby{障害}{しょうがい}が\ruby{発生}{はっせい}しても、その\ruby{影響}{えいきょう}は\ruby{当該}{とうがい}\ruby{アプリケーション}{あぷりけーしょん}に\ruby{限定}{げんてい}され、\ruby{システム}{しすてむ}\ruby{全体}{ぜんたい}に\ruby{波及}{はきゅう}することはない。

Về mặt chiến lược, sự chuyển đổi từ Dalvik sang ART cho thấy Android sẵn sàng hy sinh một phần chi phí cài đặt và dung lượng lưu trữ để đổi lấy hiệu năng và độ ổn định lâu dài. Đây là lựa chọn phù hợp với xu hướng phần cứng ngày càng mạnh hơn, trong khi kỳ vọng của người dùng về trải nghiệm mượt mà ngày càng cao. Đồng thời, ART tạo nền tảng cho các cơ chế tối ưu và bảo mật nâng cao trong tương lai, chẳng hạn như kiểm tra mã chặt chẽ hơn và tối ưu theo hành vi sử dụng thực tế.

\ruby{戦略的}{せんりゃくてき}な\ruby{観点}{かんてん}では、DalvikからARTへの\ruby{移行}{いこう}は、\ruby{Android}{あんどろいど}が\ruby{インストール}{いんすとーる}\ruby{コスト}{こすと}や\ruby{ストレージ}{すとれーじ}\ruby{消費}{しょうひ}の\ruby{一部}{いちぶ}を\ruby{犠牲}{ぎせい}にしてでも、\ruby{長期的}{ちょうきてき}な\ruby{性能}{せいのう}と\ruby{安定性}{あんていせい}を\ruby{優先}{ゆうせん}する\ruby{姿勢}{しせい}を\ruby{示}{しめ}している。これは、\ruby{ハードウェア}{はーどうぇあ}が\ruby{年々}{ねんねん}\ruby{高性能}{こうせいのう}化する\ruby{傾向}{けいこう}と、\ruby{利用者}{りようしゃ}が\ruby{滑}{なめ}らかな\ruby{体験}{たいけん}を\ruby{強}{つよ}く\ruby{期待}{きたい}する\ruby{状況}{じょうきょう}に\ruby{合致}{がっち}する\ruby{選択}{せんたく}である。同時に、ARTは\ruby{将来}{しょうらい}の\ruby{高度}{こうど}な\ruby{最適化}{さいてきか}や\ruby{セキュリティ}{せきゅりてぃ}\ruby{機構}{きこう}の\ruby{基盤}{きばん}を\ruby{提供}{ていきょう}し、\ruby{厳格}{げんかく}な\ruby{コード}{こーど}\ruby{検査}{けんさ}や\ruby{実際}{じっさい}の\ruby{利用}{りよう}\ruby{挙動}{きょどう}に\ruby{基}{もと}づく\ruby{最適化}{さいてきか}を\ruby{可能}{かのう}にする。

Tóm lại, Android Runtime là lớp kiến trúc đóng vai trò cầu nối giữa hệ điều hành và ứng dụng. Từ Dalvik đến ART, sự tiến hóa của runtime phản ánh rõ triết lý thiết kế của Android: linh hoạt ở giai đoạn đầu để mở rộng nhanh hệ sinh thái, sau đó từng bước tối ưu sâu để đảm bảo hiệu năng, ổn định và khả năng duy trì lâu dài trên quy mô toàn cầu.

\ruby{総括}{そうかつ}すると、\ruby{Android}{あんどろいど}\ruby{Runtime}{らんたいむ}は、\ruby{オペレーティング}{おぺれーてぃんぐ}\ruby{システム}{しすてむ}と\ruby{アプリケーション}{あぷりけーしょん}を\ruby{結}{むす}ぶ\ruby{橋渡}{はしわた}しの\ruby{役割}{やくわり}を\ruby{担}{にな}う\ruby{アーキテクチャ}{あーきてくちゃ}である。DalvikからARTへの\ruby{進化}{しんか}は、\ruby{Android}{あんどろいど}の\ruby{設計}{せっけい}\ruby{哲学}{てつがく}を\ruby{明確}{めいかく}に\ruby{反映}{はんえい}している。すなわち、\ruby{初期}{しょき}\ruby{段階}{だんかい}では\ruby{生態系}{せいたいけい}の\ruby{急速}{きゅうそく}な\ruby{拡大}{かくだい}を\ruby{優先}{ゆうせん}して\ruby{柔軟性}{じゅうなんせい}を\ruby{確保}{かくほ}し、その\ruby{後}{のち}に\ruby{段階的}{だんかいてき}な\ruby{最適化}{さいてきか}を\ruby{進}{すす}めることで、\ruby{性能}{せいのう}、\ruby{安定性}{あんていせい}、および\ruby{世界}{せかい}\ruby{規模}{きぼ}での\ruby{持続可能性}{じぞくかのうせい}を\ruby{実現}{じつげん}してきたのである。

\section{Android Framework}
Android\ruby{フレームワーク}{ふれーむわーく}

Android Framework là tập hợp các API và dịch vụ hệ thống cốt lõi, đóng vai trò như “bộ xương sống” của toàn bộ nền tảng Android ở mức ứng dụng. Hầu hết mọi tương tác giữa ứng dụng và hệ thống – từ hiển thị giao diện, truy cập dữ liệu, sử dụng phần cứng cho đến quản lý tiến trình – đều phải đi qua Framework. Việc tập trung các chức năng này vào một lớp thống nhất giúp Android kiểm soát chặt chẽ hành vi của ứng dụng, đồng thời cung cấp cho lập trình viên một môi trường phát triển ổn định và nhất quán.

Android Frameworkは、\ruby{中核}{ちゅうかく}となるAPIおよび\ruby{システム}{しすてむ}\ruby{サービス}{さーびす}の\ruby{集合体}{しゅうごうたい}であり、\ruby{アプリケーション}{あぷりけーしょん}\ruby{層}{そう}におけるAndroid\ruby{プラットフォーム}{ぷらっとふぉーむ}全体の「\ruby{骨格}{こっかく}」としての\ruby{役割}{やくわり}を\ruby{担}{にな}う。UIの\ruby{表示}{ひょうじ}、\ruby{データ}{でーた}への\ruby{アクセス}{あくせす}、\ruby{ハードウェア}{はーどうぇあ}の\ruby{利用}{りよう}、\ruby{プロセス}{ぷろせす}\ruby{管理}{かんり}に\ruby{至}{いた}るまで、\ruby{アプリケーション}{あぷりけーしょん}と\ruby{システム}{しすてむ}の\ruby{相互作用}{そうごさよう}の\ruby{大半}{たいはん}はFrameworkを\ruby{経由}{けいゆ}する。これらの\ruby{機能}{きのう}を\ruby{統一}{とういつ}された\ruby{層}{そう}に\ruby{集約}{しゅうやく}することで、Androidは\ruby{アプリケーション}{あぷりけーしょん}の\ruby{振}{ふ}る\ruby{舞}{ま}いを\ruby{厳密}{げんみつ}に\ruby{制御}{せいぎょ}しつつ、\ruby{開発者}{かいはつしゃ}に\ruby{安定}{あんてい}かつ\ruby{一貫性}{いっかんせい}のある\ruby{開発}{かいはつ}\ruby{環境}{かんきょう}を\ruby{提供}{ていきょう}する。

Một thành phần trọng yếu của Android Framework là hệ thống các system service chạy nền. Các service này được quản lý bởi tiến trình hệ thống và cung cấp chức năng cho toàn bộ hệ điều hành. Ví dụ, Activity Manager Service chịu trách nhiệm quản lý vòng đời ứng dụng và các activity; Window Manager Service kiểm soát việc hiển thị và sắp xếp cửa sổ; Package Manager Service quản lý cài đặt, cập nhật và quyền truy cập của ứng dụng. Mỗi service đảm nhận một trách nhiệm rõ ràng, giúp hệ thống tránh tình trạng chồng chéo logic và khó bảo trì.

Android Frameworkの\ruby{重要}{じゅうよう}な\ruby{構成要素}{こうせいようそ}の一つが、\ruby{バックグラウンド}{ばっくぐらうんど}で\ruby{動作}{どうさ}する\ruby{システム}{しすてむ}\ruby{サービス}{さーびす}\ruby{群}{ぐん}である。これらの\ruby{サービス}{さーびす}は\ruby{システム}{しすてむ}\ruby{プロセス}{ぷろせす}によって\ruby{管理}{かんり}され、\ruby{オペレーティングシステム}{おぺれーてぃんぐしすてむ}全体に\ruby{機能}{きのう}を\ruby{提供}{ていきょう}する。たとえば、Activity Manager Serviceは\ruby{アプリケーション}{あぷりけーしょん}およびActivityの\ruby{ライフサイクル}{らいふさいくる}を\ruby{管理}{かんり}し、Window Manager Serviceは\ruby{ウィンドウ}{うぃんどう}の\ruby{表示}{ひょうじ}や\ruby{配置}{はいち}を\ruby{制御}{せいぎょ}する。Package Manager Serviceは\ruby{インストール}{いんすとーる}、\ruby{更新}{こうしん}、および\ruby{アクセス}{あくせす}\ruby{権限}{けんげん}を\ruby{管理}{かんり}する。各\ruby{サービス}{さーびす}が\ruby{明確}{めいかく}な\ruby{責務}{せきむ}を\ruby{担}{にな}うことで、\ruby{ロジック}{ろじっく}の\ruby{重複}{じゅうふく}や\ruby{保守}{ほしゅ}の\ruby{困難}{こんなん}さを\ruby{回避}{かいひ}している。

Về mặt kỹ thuật, các system service thường được triển khai bằng mã native hoặc Java ở mức hệ thống, giao tiếp với nhau và với ứng dụng thông qua cơ chế IPC. Android sử dụng Binder làm nền tảng cho giao tiếp liên tiến trình, cho phép truyền dữ liệu và lời gọi hàm một cách hiệu quả và an toàn. Nhờ Binder, Android Framework có thể cung cấp các API mạnh mẽ cho ứng dụng mà vẫn đảm bảo rằng mọi thao tác nhạy cảm đều được kiểm soát ở phía hệ thống.

\ruby{技術的}{ぎじゅつてき}には、\ruby{システム}{しすてむ}\ruby{サービス}{さーびす}は\ruby{ネイティブ}{ねいてぃぶ}\ruby{コード}{こーど}またはJavaで\ruby{システム}{しすてむ}\ruby{レベル}{れべる}に\ruby{実装}{じっそう}され、IPC\ruby{機構}{きこう}を\ruby{通}{つう}じて\ruby{相互}{そうご}および\ruby{アプリケーション}{あぷりけーしょん}と\ruby{通信}{つうしん}する。Androidは\ruby{プロセス}{ぷろせす}\ruby{間}{かん}の\ruby{通信}{つうしん}の\ruby{基盤}{きばん}としてBinderを\ruby{採用}{さいよう}し、\ruby{データ}{でーた}や\ruby{関数}{かんすう}\ruby{呼}{よ}び\ruby{出}{だ}しを\ruby{効率的}{こうりつてき}かつ\ruby{安全}{あんぜん}に\ruby{伝達}{でんたつ}する。Binderにより、Android Frameworkは\ruby{強力}{きょうりょく}なAPIを\ruby{提供}{ていきょう}しつつ、\ruby{機微}{きび}な\ruby{操作}{そうさ}が\ruby{常}{つね}に\ruby{システム}{しすてむ}\ruby{側}{がわ}で\ruby{管理}{かんり}されることを\ruby{保証}{ほしょう}できる。

Một đặc điểm kiến trúc quan trọng của Android Framework là mô hình ứng dụng hướng thành phần. Thay vì một điểm vào duy nhất như hàm main trong các ứng dụng truyền thống, Android định nghĩa các thành phần độc lập như Activity, Service, Broadcast Receiver và Content Provider. Mỗi thành phần có vòng đời riêng, được hệ thống quản lý thông qua Framework. Cách tiếp cận này cho phép hệ điều hành chủ động khởi tạo, tạm dừng hoặc hủy các thành phần ứng dụng dựa trên trạng thái tài nguyên và hành vi người dùng.

Android Frameworkの\ruby{重要}{じゅうよう}な\ruby{アーキテクチャ}{あーきてくちゃ}\ruby{特性}{とくせい}は、\ruby{コンポーネント}{こんぽーねんと}\ruby{指向}{しこう}の\ruby{アプリケーション}{あぷりけーしょん}\ruby{モデル}{もでる}である。Androidは、\ruby{従来}{じゅうらい}の\ruby{アプリケーション}{あぷりけーしょん}に\ruby{見}{み}られるmain\ruby{関数}{かんすう}のような\ruby{単一}{たんいつ}の\ruby{入口}{いりぐち}ではなく、Activity、Service、Broadcast Receiver、Content Providerといった\ruby{独立}{どくりつ}した\ruby{構成要素}{こうせいようそ}を\ruby{定義}{ていぎ}する。各\ruby{コンポーネント}{こんぽーねんと}は\ruby{固有}{こゆう}の\ruby{ライフサイクル}{らいふさいくる}を\ruby{持}{も}ち、Frameworkを\ruby{通}{つう}じて\ruby{システム}{しすてむ}により\ruby{管理}{かんり}される。この\ruby{手法}{しゅほう}により、\ruby{オペレーティングシステム}{おぺれーてぃんぐしすてむ}は\ruby{資源}{しげん}\ruby{状態}{じょうたい}や\ruby{利用者}{りようしゃ}の\ruby{振}{ふ}る\ruby{舞}{ま}いに\ruby{応}{おう}じて、\ruby{アプリケーション}{あぷりけーしょん}\ruby{構成要素}{こうせいようそ}の\ruby{起動}{きどう}、\ruby{一時停止}{いちじていし}、\ruby{破棄}{はき}を\ruby{主体的}{しゅたいてき}に\ruby{制御}{せいぎょ}できる。

Cơ chế Intent đóng vai trò kết nối các thành phần trong và giữa các ứng dụng. Intent cho phép gửi yêu cầu thực hiện hành động mà không cần biết chính xác thành phần nào sẽ xử lý. Điều này tạo ra mức độ liên kết lỏng (loose coupling) giữa các ứng dụng, khuyến khích khả năng tái sử dụng và tích hợp chức năng. Từ góc nhìn hệ thống, Framework có thể can thiệp vào quá trình phân giải Intent để áp đặt các chính sách bảo mật và quyền truy cập.

Intent\ruby{機構}{きこう}は、\ruby{アプリケーション}{あぷりけーしょん}\ruby{内外}{ないがい}の\ruby{コンポーネント}{こんぽーねんと}を\ruby{接続}{せつぞく}する\ruby{役割}{やくわり}を\ruby{果}{は}たす。Intentは、どの\ruby{構成要素}{こうせいようそ}が\ruby{処理}{しょり}するかを\ruby{特定}{とくてい}することなく、\ruby{動作}{どうさ}\ruby{要求}{ようきゅう}を\ruby{送信}{そうしん}できる。これにより、\ruby{アプリケーション}{あぷりけーしょん}\ruby{間}{かん}の\ruby{疎結合}{そけつごう}が\ruby{実現}{じつげん}され、\ruby{再利用性}{さいりようせい}や\ruby{機能}{きのう}\ruby{統合}{とうごう}が\ruby{促進}{そくしん}される。\ruby{システム}{しすてむ}\ruby{視点}{してん}では、FrameworkがIntentの\ruby{解決}{かいけつ}\ruby{過程}{かてい}に\ruby{介入}{かいにゅう}し、\ruby{セキュリティ}{せきゅりてぃ}や\ruby{アクセス}{あくせす}\ruby{権限}{けんげん}の\ruby{方針}{ほうしん}を\ruby{適用}{てきよう}できる。

Android Framework cũng là nơi thực thi mô hình phân quyền. Mọi truy cập vào tài nguyên nhạy cảm như vị trí, camera hay danh bạ đều được kiểm tra thông qua các API của Framework. Thay vì để ứng dụng trực tiếp tương tác với phần cứng hoặc dữ liệu hệ thống, Framework đóng vai trò “người gác cổng”, đảm bảo rằng chỉ các ứng dụng được cấp quyền hợp lệ mới có thể thực hiện hành động tương ứng. Điều này làm giảm đáng kể bề mặt tấn công và tăng độ an toàn cho toàn bộ hệ thống.

Android Frameworkは\ruby{権限}{けんげん}\ruby{モデル}{もでる}の\ruby{実行}{じっこう}\ruby{主体}{しゅたい}でもある。\ruby{位置}{いち}\ruby{情報}{じょうほう}、\ruby{カメラ}{かめら}、\ruby{連絡先}{れんらくさき}といった\ruby{機微}{きび}な\ruby{資源}{しげん}への\ruby{アクセス}{あくせす}は、すべてFrameworkのAPIを\ruby{通}{つう}じて\ruby{検証}{けんしょう}される。\ruby{アプリケーション}{あぷりけーしょん}が\ruby{ハードウェア}{はーどうぇあ}や\ruby{システム}{しすてむ}\ruby{データ}{でーた}に\ruby{直接}{ちょくせつ}\ruby{接触}{せっしょく}するのではなく、Frameworkが「\ruby{門番}{もんばん}」として\ruby{機能}{きのう}し、\ruby{正当}{せいとう}な\ruby{権限}{けんげん}を\ruby{付与}{ふよ}された\ruby{アプリケーション}{あぷりけーしょん}のみが\ruby{対応}{たいおう}する\ruby{操作}{そうさ}を\ruby{実行}{じっこう}できることを\ruby{保証}{ほしょう}する。これにより、\ruby{攻撃}{こうげき}\ruby{対象}{たいしょう}の\ruby{表面}{ひょうめん}が\ruby{大幅}{おおはば}に\ruby{縮小}{しゅくしょう}され、\ruby{システム}{しすてむ}全体の\ruby{安全性}{あんぜんせい}が\ruby{向上}{こうじょう}する。

Từ góc độ chiến lược, Android Framework giúp Google duy trì quyền kiểm soát kiến trúc tổng thể của nền tảng, ngay cả khi hệ điều hành được triển khai trên thiết bị của nhiều nhà sản xuất khác nhau. Các thay đổi ở tầng Framework có thể mở rộng hoặc hạn chế khả năng của ứng dụng mà không cần can thiệp sâu vào kernel hay phần cứng. Đồng thời, Framework cung cấp một lớp API ổn định, cho phép hàng triệu ứng dụng phát triển song song mà không phá vỡ tính tương thích.

\ruby{戦略的}{せんりゃくてき}\ruby{観点}{かんてん}から、Android Frameworkは、\ruby{複数}{ふくすう}の\ruby{製造業者}{せいぞうぎょうしゃ}の\ruby{端末}{たんまつ}に\ruby{展開}{てんかい}される\ruby{状況}{じょうきょう}においても、Googleが\ruby{プラットフォーム}{ぷらっとふぉーむ}の\ruby{全体}{ぜんたい}\ruby{構造}{こうぞう}に\ruby{対}{たい}する\ruby{統制}{とうせい}を\ruby{維持}{いじ}することを\ruby{可能}{かのう}にする。Framework\ruby{層}{そう}での\ruby{変更}{へんこう}は、\ruby{カーネル}{かーねる}や\ruby{ハードウェア}{はーどうぇあ}に\ruby{深}{ふか}く\ruby{立}{た}ち\ruby{入}{い}ることなく、\ruby{アプリケーション}{あぷりけーしょん}の\ruby{能力}{のうりょく}を\ruby{拡張}{かくちょう}または\ruby{制限}{せいげん}できる。\ruby{同時}{どうじ}に、Frameworkは\ruby{安定}{あんてい}したAPI\ruby{層}{そう}を\ruby{提供}{ていきょう}し、\ruby{数百万}{すうひゃくまん}の\ruby{アプリケーション}{あぷりけーしょん}が\ruby{互換性}{ごかんせい}を\ruby{損}{そこ}なうことなく\ruby{並行}{へいこう}して\ruby{開発}{かいはつ}されることを\ruby{可能}{かのう}にする。

Tóm lại, Android Framework là lớp kiến trúc trung tâm, nơi hội tụ các quyết định kỹ thuật về quản lý tài nguyên, bảo mật và mô hình ứng dụng. Đây chính là cầu nối giữa hệ điều hành và lập trình viên, đảm bảo Android vừa là một nền tảng mở cho sáng tạo ứng dụng, vừa là một hệ thống được kiểm soát chặt chẽ để duy trì hiệu năng và độ ổn định trên quy mô lớn.

\ruby{要約}{ようやく}すると、Android Frameworkは\ruby{資源}{しげん}\ruby{管理}{かんり}、\ruby{セキュリティ}{せきゅりてぃ}、および\ruby{アプリケーション}{あぷりけーしょん}\ruby{モデル}{もでる}に\ruby{関}{かん}する\ruby{技術的}{ぎじゅつてき}\ruby{意思決定}{いしけってい}が\ruby{集約}{しゅうやく}される\ruby{中核}{ちゅうかく}\ruby{アーキテクチャ}{あーきてくちゃ}\ruby{層}{そう}である。これは、\ruby{オペレーティングシステム}{おぺれーてぃんぐしすてむ}と\ruby{開発者}{かいはつしゃ}を\ruby{結}{むす}ぶ\ruby{橋渡}{はしわた}しとして\ruby{機能}{きのう}し、Androidが\ruby{創造性}{そうぞうせい}のための\ruby{オープン}{おーぷん}な\ruby{基盤}{きばん}であると\ruby{同時}{どうじ}に、\ruby{大規模}{だいきぼ}な\ruby{運用}{うんよう}に\ruby{耐}{た}える\ruby{性能}{せいのう}と\ruby{安定性}{あんていせい}を\ruby{維持}{いじ}するために\ruby{厳格}{げんかく}に\ruby{管理}{かんり}された\ruby{システム}{しすてむ}であることを\ruby{保証}{ほしょう}する。

\section{Application Layer}
\ruby{アプリケーション}{あぷりけーしょん}\ruby{層}{そう}

Application Layer bao gồm toàn bộ các ứng dụng chạy trên Android, từ ứng dụng hệ thống do nhà sản xuất hoặc Google cung cấp cho đến các ứng dụng bên thứ ba được cài đặt bởi người dùng. Về mặt kỹ thuật, không có sự khác biệt cơ bản giữa ứng dụng hệ thống và ứng dụng của bên thứ ba về mô hình thực thi: tất cả đều chạy dựa trên Android Runtime và tương tác với hệ thống thông qua Android Framework. Sự khác biệt chủ yếu nằm ở tập quyền được cấp và mức độ tích hợp với hệ điều hành.

Application Layerは、\ruby{製造者}{せいぞうしゃ}または\ruby{Google}{ぐーぐる}が\ruby{提供}{ていきょう}する\ruby{システム}{しすてむ}\ruby{アプリケーション}{あぷりけーしょん}から、\ruby{利用者}{りようしゃ}が\ruby{導入}{どうにゅう}する\ruby{第三者}{だいさんしゃ}\ruby{製}{せい}の\ruby{アプリケーション}{あぷりけーしょん}まで、Android上で\ruby{動作}{どうさ}する\ruby{全}{すべ}ての\ruby{アプリケーション}{あぷりけーしょん}を\ruby{包含}{ほうがん}する。\ruby{技術的}{ぎじゅつてき}には、\ruby{実行}{じっこう}\ruby{モデル}{もでる}の\ruby{観点}{かんてん}において、\ruby{システム}{しすてむ}\ruby{アプリケーション}{あぷりけーしょん}と\ruby{第三者}{だいさんしゃ}\ruby{アプリケーション}{あぷりけーしょん}の\ruby{間}{あいだ}に\ruby{本質的}{ほんしつてき}な\ruby{差異}{さい}は\ruby{存在}{そんざい}しない。\ruby{いずれ}{いずれ}もAndroid Runtimeを\ruby{基盤}{きばん}として\ruby{実行}{じっこう}され、Android Frameworkを\ruby{通}{とお}じて\ruby{システム}{しすてむ}と\ruby{相互作用}{そうごさよう}する。\ruby{主}{おも}な\ruby{違}{ちが}いは、\ruby{付与}{ふよ}される\ruby{権限}{けんげん}の\ruby{集合}{しゅうごう}と、\ruby{オペレーティングシステム}{おぺれーてぃんぐしすてむ}との\ruby{統合度}{とうごうど}に\ruby{集約}{しゅうやく}される。

Mỗi ứng dụng Android được triển khai dưới dạng một gói độc lập, chạy trong một tiến trình riêng và có một UID riêng do hệ thống cấp phát. Mô hình này tạo ra sandbox cho từng ứng dụng, đảm bảo rằng lỗi hoặc hành vi bất thường của một ứng dụng không ảnh hưởng trực tiếp đến các ứng dụng khác hay đến hệ thống. Từ góc nhìn bảo mật, đây là lớp phòng vệ đầu tiên ở mức ứng dụng, bổ sung cho các cơ chế bảo vệ ở Linux Kernel và Android Framework.

\ruby{各}{かく}\ruby{アプリケーション}{あぷりけーしょん}は\ruby{独立}{どくりつ}した\ruby{パッケージ}{ぱっけーじ}として\ruby{展開}{てんかい}され、\ruby{個別}{こべつ}の\ruby{プロセス}{ぷろせす}で\ruby{実行}{じっこう}され、\ruby{システム}{しすてむ}によって\ruby{割}{わ}り\ruby{当}{あ}てられた\ruby{固有}{こゆう}のUIDを\ruby{持}{も}つ。この\ruby{モデル}{もでる}は、\ruby{各}{かく}\ruby{アプリケーション}{あぷりけーしょん}ごとに\ruby{サンドボックス}{さんどぼっくす}を\ruby{形成}{けいせい}し、\ruby{一}{ひと}つの\ruby{アプリケーション}{あぷりけーしょん}における\ruby{不具合}{ふぐあい}や\ruby{異常}{いじょう}\ruby{動作}{どうさ}が、\ruby{他}{ほか}の\ruby{アプリケーション}{あぷりけーしょん}や\ruby{システム}{しすてむ}に\ruby{直接的}{ちょくせつてき}な\ruby{影響}{えいきょう}を\ruby{及}{およ}ぼさないことを\ruby{保証}{ほしょう}する。\ruby{セキュリティ}{せきゅりてぃ}の\ruby{観点}{かんてん}から、これは\ruby{アプリケーション}{あぷりけーしょん}\ruby{層}{そう}における\ruby{第一}{だいいち}の\ruby{防御}{ぼうぎょ}\ruby{線}{せん}であり、Linux KernelおよびAndroid Frameworkの\ruby{保護}{ほご}\ruby{機構}{きこう}を\ruby{補完}{ほかん}する。

Ứng dụng không được phép truy cập trực tiếp vào kernel, driver hay phần cứng. Mọi tương tác với hệ thống đều phải thông qua các API chính thức của Android Framework. Điều này có ý nghĩa kỹ thuật quan trọng: Framework trở thành điểm kiểm soát duy nhất, nơi hệ điều hành có thể áp đặt các chính sách về quyền truy cập, quản lý tài nguyên và vòng đời ứng dụng. Nhờ đó, Android có thể duy trì tính ổn định ngay cả khi hệ sinh thái ứng dụng phát triển với tốc độ rất nhanh và không đồng nhất về chất lượng.

\ruby{アプリケーション}{あぷりけーしょん}は\ruby{カーネル}{かーねる}、\ruby{ドライバ}{どらいば}、または\ruby{ハードウェア}{はーどうぇあ}へ\ruby{直接}{ちょくせつ}アクセスすることは\ruby{許}{ゆる}されていない。\ruby{すべ}{すべ}ての\ruby{相互作用}{そうごさよう}は、Android Frameworkの\ruby{公式}{こうしき}APIを\ruby{通}{とお}じて\ruby{行}{おこな}われる。これは\ruby{技術的}{ぎじゅつてき}に\ruby{重要}{じゅうよう}な\ruby{意味}{いみ}を\ruby{持}{も}つ。すなわち、Frameworkが\ruby{唯一}{ゆいいつ}の\ruby{制御}{せいぎょ}\ruby{点}{てん}となり、\ruby{オペレーティングシステム}{おぺれーてぃんぐしすてむ}が\ruby{アクセス}{あくせす}\ruby{権限}{けんげん}、\ruby{資源}{しげん}\ruby{管理}{かんり}、および\ruby{アプリケーション}{あぷりけーしょん}の\ruby{ライフサイクル}{らいふさいくる}に\ruby{関}{かん}する\ruby{方針}{ほうしん}を\ruby{適用}{てきよう}できるからである。これにより、\ruby{アプリケーション}{あぷりけーしょん}\ruby{生態系}{せいたいけい}が\ruby{高速}{こうそく}に\ruby{成長}{せいちょう}し、\ruby{品質}{ひんしつ}が\ruby{不均一}{ふきんいつ}であっても、Androidは\ruby{安定性}{あんていせい}を\ruby{維持}{いじ}できる。

Application Layer cũng phản ánh rõ mô hình ứng dụng hướng thành phần của Android. Một ứng dụng không chỉ là một chương trình chạy liên tục, mà là tập hợp các thành phần có thể được hệ thống kích hoạt khi cần thiết. Ví dụ, một activity có thể được tạo ra chỉ để xử lý một tác vụ ngắn, sau đó bị hủy khi không còn cần thiết. Cách tiếp cận này giúp hệ điều hành chủ động quản lý tài nguyên, đặc biệt là bộ nhớ và pin, thay vì để ứng dụng toàn quyền kiểm soát như trên các nền tảng truyền thống.

Application Layerは、Androidの\ruby{コンポーネント}{こんぽーねんと}\ruby{指向}{しこう}の\ruby{アプリケーション}{あぷりけーしょん}\ruby{モデル}{もでる}を\ruby{明確}{めいかく}に\ruby{反映}{はんえい}している。\ruby{アプリケーション}{あぷりけーしょん}は\ruby{常時}{じょうじ}\ruby{実行}{じっこう}される\ruby{単一}{たんいつ}の\ruby{プログラム}{ぷろぐらむ}ではなく、\ruby{必要}{ひつよう}に\ruby{応}{おう}じて\ruby{システム}{しすてむ}から\ruby{起動}{きどう}される\ruby{複数}{ふくすう}の\ruby{コンポーネント}{こんぽーねんと}の\ruby{集合}{しゅうごう}である。たとえば、\ruby{一}{ひと}つの\ruby{アクティビティ}{あくてぃびてぃ}は、\ruby{短時間}{たんじかん}の\ruby{処理}{しょり}を\ruby{行}{おこな}うためだけに\ruby{生成}{せいせい}され、\ruby{不要}{ふよう}になれば\ruby{破棄}{はき}される。この\ruby{アプローチ}{あぷろーち}により、\ruby{オペレーティングシステム}{おぺれーてぃんぐしすてむ}は\ruby{メモリ}{めもり}や\ruby{バッテリー}{ばってりー}といった\ruby{資源}{しげん}を\ruby{能動的}{のうどうてき}に\ruby{管理}{かんり}でき、\ruby{従来}{じゅうらい}の\ruby{基盤}{きばん}のように\ruby{アプリケーション}{あぷりけーしょん}へ\ruby{全面的}{ぜんめんてき}な\ruby{制御}{せいぎょ}を\ruby{委}{ゆだ}ねる\ruby{必要}{ひつよう}がない。

Từ góc độ khả năng mở rộng, kiến trúc phân tầng mang lại lợi ích rõ rệt cho Application Layer. Khi Android Framework được mở rộng với các API mới, ứng dụng có thể tận dụng các khả năng đó mà không cần quan tâm đến thay đổi ở kernel hay phần cứng. Ngược lại, khi phần cứng thay đổi hoặc được nâng cấp, các ứng dụng hiện có vẫn có thể hoạt động bình thường nhờ HAL và Framework che giấu sự khác biệt. Điều này tạo ra tính ổn định lâu dài cho ứng dụng, một yếu tố then chốt để xây dựng hệ sinh thái phần mềm lớn.

\ruby{拡張性}{かくちょうせい}の\ruby{観点}{かんてん}から、\ruby{階層}{かいそう}\ruby{化}{か}された\ruby{アーキテクチャ}{あーきてくちゃ}はApplication Layerに\ruby{明確}{めいかく}な\ruby{利点}{りてん}を\ruby{もたら}{もたら}す。Android Frameworkが\ruby{新}{あたら}しいAPIで\ruby{拡張}{かくちょう}されると、\ruby{アプリケーション}{あぷりけーしょん}は\ruby{カーネル}{かーねる}や\ruby{ハードウェア}{はーどうぇあ}の\ruby{変更}{へんこう}を\ruby{意識}{いしき}することなく、その\ruby{機能}{きのう}を\ruby{活用}{かつよう}できる。\ruby{一方}{いっぽう}、\ruby{ハードウェア}{はーどうぇあ}が\ruby{変更}{へんこう}または\ruby{更新}{こうしん}されても、HALおよびFrameworkが\ruby{差異}{さい}を\ruby{隠蔽}{いんぺい}することで、\ruby{既存}{きそん}の\ruby{アプリケーション}{あぷりけーしょん}は\ruby{通常}{つうじょう}どおり\ruby{動作}{どうさ}できる。これは、\ruby{大規模}{だいきぼ}な\ruby{ソフトウェア}{そふとうぇあ}\ruby{生態系}{せいたいけい}を\ruby{構築}{こうちく}するうえで\ruby{重要}{じゅうよう}な、\ruby{長期的}{ちょうきてき}\ruby{安定性}{あんていせい}を\ruby{もたら}{もたら}す。

Một ý nghĩa chiến lược khác của Application Layer là khả năng kiểm soát trải nghiệm người dùng ở quy mô lớn. Thông qua các quy định về API, permission và hành vi ứng dụng, Android có thể định hướng cách ứng dụng được thiết kế và vận hành. Điều này giúp giảm thiểu rủi ro từ các ứng dụng kém chất lượng, đồng thời tạo ra một chuẩn chung cho trải nghiệm người dùng trên hàng loạt thiết bị khác nhau.

Application Layerの\ruby{戦略的}{せんりゃくてき}な\ruby{意義}{いぎ}の\ruby{一}{ひと}つは、\ruby{大規模}{だいきぼ}に\ruby{利用者}{りようしゃ}\ruby{体験}{たいけん}を\ruby{制御}{せいぎょ}できる\ruby{点}{てん}にある。API、\ruby{パーミッション}{ぱーみっしょん}、および\ruby{アプリケーション}{あぷりけーしょん}\ruby{挙動}{きょどう}に\ruby{関}{かん}する\ruby{規定}{きてい}を\ruby{通}{とお}じて、Androidは\ruby{設計}{せっけい}および\ruby{運用}{うんよう}の\ruby{方向性}{ほうこうせい}を\ruby{誘導}{ゆうどう}できる。これにより、\ruby{低品質}{ていひんしつ}な\ruby{アプリケーション}{あぷりけーしょん}に\ruby{起因}{きいん}する\ruby{リスク}{りすく}を\ruby{低減}{ていげん}しつつ、\ruby{多様}{たよう}な\ruby{端末}{たんまつ}に\ruby{共通}{きょうつう}する\ruby{体験}{たいけん}の\ruby{標準}{ひょうじゅん}を\ruby{形成}{けいせい}する。

Tóm lại, Application Layer là nơi kiến trúc Android thể hiện giá trị cuối cùng: cung cấp một nền tảng mở cho phát triển ứng dụng, nhưng vẫn duy trì được mức độ kiểm soát cần thiết để đảm bảo an toàn, hiệu năng và khả năng mở rộng. Chính sự kết hợp chặt chẽ giữa Application Layer và các lớp bên dưới đã giúp Android hình thành một hệ sinh thái ứng dụng rộng lớn, đa dạng và có khả năng phát triển bền vững trong dài hạn.

\ruby{総括}{そうかつ}すると、Application LayerはAndroid\ruby{アーキテクチャ}{あーきてくちゃ}の\ruby{最終的}{さいしゅうてき}な\ruby{価値}{かち}が\ruby{具現化}{ぐげんか}される\ruby{領域}{りょういき}である。すなわち、\ruby{アプリケーション}{あぷりけーしょん}\ruby{開発}{かいはつ}に\ruby{開放}{かいほう}された\ruby{基盤}{きばん}を\ruby{提供}{ていきょう}しつつ、\ruby{安全性}{あんぜんせい}、\ruby{性能}{せいのう}、および\ruby{拡張性}{かくちょうせい}を\ruby{確保}{かくほ}するために\ruby{必要}{ひつよう}な\ruby{制御}{せいぎょ}を\ruby{維持}{いじ}する。Application Layerと\ruby{下位}{かい}\ruby{層}{そう}との\ruby{緊密}{きんみつ}な\ruby{連携}{れんけい}こそが、Androidに\ruby{広範}{こうはん}で\ruby{多様}{たよう}な\ruby{アプリケーション}{あぷりけーしょん}\ruby{生態系}{せいたいけい}を\ruby{形成}{けいせい}させ、\ruby{長期}{ちょうき}にわたる\ruby{持続的}{じぞくてき}\ruby{成長}{せいちょう}を\ruby{可能}{かのう}にしている。
