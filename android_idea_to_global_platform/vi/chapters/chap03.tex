\chapter{Kiến trúc kỹ thuật cốt lõi của Android}

Android không chỉ là một hệ điều hành di động phổ biến, mà còn là một nền tảng phần mềm được thiết kế với tư duy kỹ thuật rõ ràng và mang tính chiến lược dài hạn. Đối với kỹ sư CNTT, việc hiểu kiến trúc Android không dừng ở mức “các lớp thành phần”, mà quan trọng hơn là nắm được vai trò, ranh giới trách nhiệm và lý do tồn tại của từng lớp trong toàn bộ hệ thống. Kiến trúc này cho phép Android vận hành ổn định trên hàng tỷ thiết bị với cấu hình phần cứng rất khác nhau, đồng thời vẫn đảm bảo hiệu năng, bảo mật và khả năng mở rộng.

Trong các lớp kiến trúc của Android, Linux Kernel đóng vai trò nền tảng, quyết định trực tiếp đến độ ổn định, khả năng quản lý tài nguyên và mức độ an toàn của toàn bộ hệ điều hành. Việc Android lựa chọn Linux Kernel không phải là quyết định mang tính tình thế, mà là một lựa chọn chiến lược, ảnh hưởng sâu rộng đến toàn bộ hệ sinh thái Android sau này.

\section{Linux Kernel}

Linux Kernel là lớp thấp nhất trong kiến trúc Android và đóng vai trò như “hệ điều hành lõi” thực sự. Mọi thành phần phía trên, từ Android Runtime đến Framework và ứng dụng, đều gián tiếp phụ thuộc vào các cơ chế mà kernel cung cấp. Android không sử dụng Linux Kernel một cách nguyên bản, mà có các tùy chỉnh để phù hợp với môi trường thiết bị di động, tuy nhiên các chức năng cốt lõi của kernel vẫn được giữ nguyên.

Trước hết, Linux Kernel chịu trách nhiệm quản lý tiến trình. Mỗi ứng dụng Android chạy trong một tiến trình riêng biệt, với một không gian địa chỉ độc lập. Kernel đảm nhiệm việc lập lịch CPU, phân chia thời gian xử lý giữa các tiến trình, cũng như chuyển đổi ngữ cảnh khi cần thiết. Cách tiếp cận này giúp Android tận dụng trực tiếp cơ chế đa nhiệm đã được kiểm chứng của Linux, đồng thời tạo nền tảng cho mô hình cách ly ứng dụng, vốn là yêu cầu bắt buộc trong môi trường di động nhiều rủi ro bảo mật.

Bên cạnh quản lý tiến trình, quản lý bộ nhớ là một nhiệm vụ then chốt của Linux Kernel trong Android. Kernel cung cấp cơ chế bộ nhớ ảo, cho phép mỗi tiến trình “nhìn thấy” một không gian bộ nhớ riêng, trong khi thực tế bộ nhớ vật lý được chia sẻ và quản lý tập trung. Trên các thiết bị có tài nguyên hạn chế như điện thoại di động, việc kiểm soát bộ nhớ hiệu quả là yếu tố sống còn. Android bổ sung thêm các cơ chế như low memory killer daemon (LMKD) để phối hợp với kernel trong việc chủ động giải phóng tài nguyên khi hệ thống rơi vào trạng thái thiếu bộ nhớ.

Linux Kernel cũng là nơi quản lý toàn bộ hệ thống driver. Tất cả các thành phần phần cứng như màn hình, camera, âm thanh, cảm biến, Wi-Fi hay Bluetooth đều được điều khiển thông qua driver chạy trong không gian kernel. Việc đặt driver ở tầng kernel giúp đảm bảo hiệu năng cao và khả năng truy cập trực tiếp phần cứng, đồng thời cho phép các lớp phía trên tương tác với phần cứng theo cách thống nhất, thông qua các giao diện đã được trừu tượng hóa.

Một khía cạnh quan trọng khác là tính ổn định và độ tin cậy của hệ thống. Linux Kernel đã trải qua hàng chục năm phát triển, được kiểm thử trong nhiều môi trường khác nhau, từ máy chủ, hệ thống nhúng đến thiết bị cá nhân. Android kế thừa trực tiếp sự ổn định này, thay vì phải xây dựng một kernel mới từ đầu. Khi kernel gặp lỗi nghiêm trọng, cơ chế phân tách tiến trình và không gian bộ nhớ giúp hạn chế phạm vi ảnh hưởng, tránh việc toàn bộ hệ thống bị sập chỉ vì lỗi của một ứng dụng.

Về bảo mật, Linux Kernel đóng vai trò nền tảng cho mô hình an toàn của Android. Mỗi ứng dụng được gán một UID riêng, chạy trong sandbox độc lập. Kernel chịu trách nhiệm thực thi các quyền truy cập tài nguyên ở mức thấp nhất, ngăn chặn ứng dụng truy cập trái phép vào bộ nhớ, file hệ thống hay tài nguyên của ứng dụng khác. Ngoài ra, Android còn tích hợp SELinux ở chế độ enforcing để áp đặt các chính sách kiểm soát truy cập bắt buộc, tăng cường khả năng phòng vệ trước các lỗ hổng zero-day.

Từ góc nhìn chiến lược, việc lựa chọn Linux Kernel mang lại cho Android ba lợi thế lớn. Thứ nhất, Android có thể tận dụng trực tiếp cộng đồng mã nguồn mở khổng lồ của Linux, bao gồm các bản vá bảo mật, cải tiến hiệu năng và hỗ trợ phần cứng mới. Thứ hai, các nhà sản xuất thiết bị vốn đã quen thuộc với Linux có thể dễ dàng tích hợp Android vào sản phẩm của mình. Thứ ba, Android tránh được rủi ro kỹ thuật và chi phí khổng lồ nếu phải tự phát triển và duy trì một kernel riêng.

Tóm lại, Linux Kernel không chỉ là một lớp kỹ thuật trong kiến trúc Android, mà là nền móng quyết định đến hiệu năng, độ ổn định và tính an toàn của toàn bộ hệ điều hành. Mọi lớp phía trên đều được xây dựng với giả định rằng kernel cung cấp một môi trường thực thi đáng tin cậy, hiệu quả và có khả năng mở rộng lâu dài.

\section{Hardware Abstraction Layer (HAL)}

Hardware Abstraction Layer (HAL) là lớp nằm giữa Linux Kernel và Android Framework, có nhiệm vụ trừu tượng hóa phần cứng và cung cấp các giao diện chuẩn để phần mềm hệ thống có thể truy cập tài nguyên phần cứng mà không phụ thuộc vào chi tiết triển khai cụ thể. Từ góc nhìn kỹ thuật, HAL là lời giải trực tiếp cho bài toán phân mảnh phần cứng – vấn đề mang tính sống còn đối với một hệ điều hành được triển khai trên hàng nghìn mẫu thiết bị khác nhau.

Trong Android, mỗi loại phần cứng quan trọng đều có một HAL tương ứng, ví dụ như Camera HAL, Audio HAL, Sensor HAL hay Bluetooth HAL. Mỗi HAL định nghĩa một tập các hàm và cấu trúc dữ liệu chuẩn mà Android Framework có thể gọi. Phần triển khai cụ thể của các hàm này do nhà sản xuất thiết bị (OEM) hoặc nhà cung cấp chipset đảm nhiệm, dựa trên đặc điểm phần cứng thực tế. Nhờ đó, Framework chỉ làm việc với “hợp đồng” kỹ thuật đã được chuẩn hóa, thay vì phải xử lý trực tiếp sự khác biệt giữa các chip hay bo mạch.

Về mặt kiến trúc, HAL đóng vai trò như một ranh giới kỹ thuật rõ ràng. Phía dưới HAL là kernel và driver, gắn chặt với phần cứng cụ thể. Phía trên HAL là Android Framework, nơi logic hệ điều hành và API cho lập trình viên được triển khai. Ranh giới này giúp giảm sự phụ thuộc chặt chẽ (tight coupling) giữa các lớp, từ đó tăng khả năng bảo trì và mở rộng hệ thống. Khi một thành phần phần cứng được thay thế hoặc nâng cấp, nhà sản xuất chỉ cần cập nhật HAL tương ứng, trong khi phần còn lại của hệ điều hành có thể giữ nguyên.

Một điểm quan trọng khác của HAL là khả năng hỗ trợ phát triển song song. Google có thể tiếp tục phát triển Android Framework và các phiên bản hệ điều hành mới, trong khi các nhà sản xuất phần cứng phát triển HAL cho thiết bị của họ dựa trên các đặc tả đã công bố. Cách tiếp cận này giúp rút ngắn thời gian đưa sản phẩm ra thị trường, đồng thời giảm xung đột giữa các bên tham gia vào chuỗi giá trị của Android.

Từ Android 8.0 trở đi, Google giới thiệu khái niệm Treble, trong đó HAL được chuẩn hóa và tách biệt mạnh mẽ hơn thông qua các giao diện ổn định. Điều này cho phép cập nhật phiên bản Android mới mà không yêu cầu thay đổi toàn bộ phần mềm tầng thấp do OEM cung cấp. Về bản chất, Treble không tạo ra HAL, mà khai thác triệt để vai trò vốn có của HAL như một lớp cách ly giữa phần cứng và phần mềm hệ thống.

Về hiệu năng, HAL được thiết kế để giảm thiểu chi phí trung gian. Các lời gọi từ Framework xuống HAL thường là các lời gọi native, tránh overhead không cần thiết. Điều này đặc biệt quan trọng với các thành phần nhạy cảm về hiệu năng như camera hay audio, nơi độ trễ nhỏ cũng có thể ảnh hưởng trực tiếp đến trải nghiệm người dùng.

Xét trên phương diện chiến lược, HAL cho phép Android duy trì một nền tảng phần mềm thống nhất trong khi vẫn hỗ trợ sự đa dạng gần như không giới hạn của phần cứng. Đây là yếu tố then chốt giúp Android mở rộng nhanh chóng trên thị trường toàn cầu. Không có HAL, mỗi biến thể phần cứng mới sẽ kéo theo những thay đổi sâu rộng ở tầng Framework và ứng dụng, khiến hệ sinh thái trở nên khó kiểm soát và tốn kém chi phí bảo trì.

Tóm lại, Hardware Abstraction Layer không chỉ là một lớp kỹ thuật trung gian, mà là một quyết định kiến trúc mang tính chiến lược. HAL giúp Android cân bằng giữa tính mở, khả năng mở rộng và yêu cầu ổn định lâu dài, đồng thời tạo điều kiện để nhiều bên cùng tham gia phát triển hệ sinh thái mà không phá vỡ cấu trúc tổng thể của hệ điều hành.

\section{Android Runtime}

Android Runtime là môi trường chịu trách nhiệm thực thi mã ứng dụng Android. Không giống các hệ điều hành truyền thống, nơi ứng dụng thường được biên dịch trực tiếp thành mã máy và chạy thẳng trên hệ điều hành, Android lựa chọn một mô hình trung gian: ứng dụng được viết bằng Java hoặc Kotlin, biên dịch thành bytecode, sau đó được thực thi trong một runtime chuyên biệt. Quyết định này phản ánh rõ định hướng của Android trong việc cân bằng giữa tính linh hoạt, khả năng kiểm soát và hiệu năng.

Trong các phiên bản Android đầu tiên, môi trường thực thi là Dalvik Virtual Machine. Dalvik được thiết kế riêng cho thiết bị di động, khác với Java Virtual Machine truyền thống vốn hướng tới máy tính để bàn và máy chủ. Một đặc điểm kỹ thuật quan trọng của Dalvik là kiến trúc dựa trên thanh ghi (register-based), thay vì dựa trên ngăn xếp (stack-based) như JVM. Cách tiếp cận này giúp giảm số lượng lệnh cần thiết khi thực thi bytecode, từ đó tiết kiệm CPU và năng lượng – yếu tố đặc biệt quan trọng trên thiết bị di động.

Dalvik sử dụng định dạng bytecode riêng là DEX (Dalvik Executable), được tối ưu để nhiều lớp (class) có thể dùng chung hằng số và dữ liệu, giảm kích thước bộ nhớ. Ở giai đoạn đầu, Dalvik chủ yếu dựa vào cơ chế JIT (Just-In-Time Compilation), tức là mã bytecode được biên dịch sang mã máy ngay trong quá trình chạy. Cách làm này giúp giảm thời gian cài đặt ứng dụng và tiết kiệm dung lượng lưu trữ, nhưng đánh đổi bằng hiệu năng không ổn định và mức tiêu thụ CPU cao tại thời điểm runtime.

Những hạn chế này dần bộc lộ khi ứng dụng Android ngày càng phức tạp. Từ Android 5.0, Google giới thiệu Android Runtime (ART) để thay thế hoàn toàn Dalvik. Sự thay đổi cốt lõi của ART là chuyển từ JIT sang AOT (Ahead-Of-Time Compilation). Thay vì biên dịch khi chạy, ART biên dịch bytecode thành mã máy ngay trong quá trình cài đặt ứng dụng. Kết quả là ứng dụng khởi động nhanh hơn, thực thi ổn định hơn và giảm tải cho CPU trong quá trình sử dụng.

Từ góc nhìn quản lý bộ nhớ, ART mang lại những cải tiến đáng kể. Cơ chế garbage collection được thiết kế lại để giảm thời gian dừng (pause time), hạn chế hiện tượng giật, lag khi ứng dụng đang chạy. ART cũng cung cấp các công cụ profiling và debugging tốt hơn, giúp lập trình viên và hệ thống theo dõi hành vi bộ nhớ một cách chính xác hơn. Điều này không chỉ cải thiện trải nghiệm người dùng, mà còn nâng cao chất lượng phát triển ứng dụng trong toàn bộ hệ sinh thái.

Một điểm quan trọng khác là mô hình “mỗi ứng dụng một runtime instance”. Mỗi ứng dụng Android chạy trong một tiến trình riêng, với một instance ART riêng biệt. Cách tổ chức này, kết hợp với sandbox ở mức Linux Kernel, tạo nên một lớp cách ly vững chắc giữa các ứng dụng. Nếu một runtime gặp lỗi nghiêm trọng, ảnh hưởng sẽ bị giới hạn trong phạm vi ứng dụng đó, thay vì lan sang toàn bộ hệ thống.

Về mặt chiến lược, sự chuyển đổi từ Dalvik sang ART cho thấy Android sẵn sàng hy sinh một phần chi phí cài đặt và dung lượng lưu trữ để đổi lấy hiệu năng và độ ổn định lâu dài. Đây là lựa chọn phù hợp với xu hướng phần cứng ngày càng mạnh hơn, trong khi kỳ vọng của người dùng về trải nghiệm mượt mà ngày càng cao. Đồng thời, ART tạo nền tảng cho các cơ chế tối ưu và bảo mật nâng cao trong tương lai, chẳng hạn như kiểm tra mã chặt chẽ hơn và tối ưu theo hành vi sử dụng thực tế.

Tóm lại, Android Runtime là lớp kiến trúc đóng vai trò cầu nối giữa hệ điều hành và ứng dụng. Từ Dalvik đến ART, sự tiến hóa của runtime phản ánh rõ triết lý thiết kế của Android: linh hoạt ở giai đoạn đầu để mở rộng nhanh hệ sinh thái, sau đó từng bước tối ưu sâu để đảm bảo hiệu năng, ổn định và khả năng duy trì lâu dài trên quy mô toàn cầu.

\section{Android Framework}

Android Framework là tập hợp các API và dịch vụ hệ thống cốt lõi, đóng vai trò như “bộ xương sống” của toàn bộ nền tảng Android ở mức ứng dụng. Hầu hết mọi tương tác giữa ứng dụng và hệ thống – từ hiển thị giao diện, truy cập dữ liệu, sử dụng phần cứng cho đến quản lý tiến trình – đều phải đi qua Framework. Việc tập trung các chức năng này vào một lớp thống nhất giúp Android kiểm soát chặt chẽ hành vi của ứng dụng, đồng thời cung cấp cho lập trình viên một môi trường phát triển ổn định và nhất quán.

Một thành phần trọng yếu của Android Framework là hệ thống các system service chạy nền. Các service này được quản lý bởi tiến trình hệ thống và cung cấp chức năng cho toàn bộ hệ điều hành. Ví dụ, Activity Manager Service chịu trách nhiệm quản lý vòng đời ứng dụng và các activity; Window Manager Service kiểm soát việc hiển thị và sắp xếp cửa sổ; Package Manager Service quản lý cài đặt, cập nhật và quyền truy cập của ứng dụng. Mỗi service đảm nhận một trách nhiệm rõ ràng, giúp hệ thống tránh tình trạng chồng chéo logic và khó bảo trì.

Về mặt kỹ thuật, các system service thường được triển khai bằng mã native hoặc Java ở mức hệ thống, giao tiếp với nhau và với ứng dụng thông qua cơ chế IPC. Android sử dụng Binder làm nền tảng cho giao tiếp liên tiến trình, cho phép truyền dữ liệu và lời gọi hàm một cách hiệu quả và an toàn. Nhờ Binder, Android Framework có thể cung cấp các API mạnh mẽ cho ứng dụng mà vẫn đảm bảo rằng mọi thao tác nhạy cảm đều được kiểm soát ở phía hệ thống.

Một đặc điểm kiến trúc quan trọng của Android Framework là mô hình ứng dụng hướng thành phần. Thay vì một điểm vào duy nhất như hàm main trong các ứng dụng truyền thống, Android định nghĩa các thành phần độc lập như Activity, Service, Broadcast Receiver và Content Provider. Mỗi thành phần có vòng đời riêng, được hệ thống quản lý thông qua Framework. Cách tiếp cận này cho phép hệ điều hành chủ động khởi tạo, tạm dừng hoặc hủy các thành phần ứng dụng dựa trên trạng thái tài nguyên và hành vi người dùng.

Cơ chế Intent đóng vai trò kết nối các thành phần trong và giữa các ứng dụng. Intent cho phép gửi yêu cầu thực hiện hành động mà không cần biết chính xác thành phần nào sẽ xử lý. Điều này tạo ra mức độ liên kết lỏng (loose coupling) giữa các ứng dụng, khuyến khích khả năng tái sử dụng và tích hợp chức năng. Từ góc nhìn hệ thống, Framework có thể can thiệp vào quá trình phân giải Intent để áp đặt các chính sách bảo mật và quyền truy cập.

Android Framework cũng là nơi thực thi mô hình phân quyền. Mọi truy cập vào tài nguyên nhạy cảm như vị trí, camera hay danh bạ đều được kiểm tra thông qua các API của Framework. Thay vì để ứng dụng trực tiếp tương tác với phần cứng hoặc dữ liệu hệ thống, Framework đóng vai trò “người gác cổng”, đảm bảo rằng chỉ các ứng dụng được cấp quyền hợp lệ mới có thể thực hiện hành động tương ứng. Điều này làm giảm đáng kể bề mặt tấn công và tăng độ an toàn cho toàn bộ hệ thống.

Từ góc độ chiến lược, Android Framework giúp Google duy trì quyền kiểm soát kiến trúc tổng thể của nền tảng, ngay cả khi hệ điều hành được triển khai trên thiết bị của nhiều nhà sản xuất khác nhau. Các thay đổi ở tầng Framework có thể mở rộng hoặc hạn chế khả năng của ứng dụng mà không cần can thiệp sâu vào kernel hay phần cứng. Đồng thời, Framework cung cấp một lớp API ổn định, cho phép hàng triệu ứng dụng phát triển song song mà không phá vỡ tính tương thích.

Tóm lại, Android Framework là lớp kiến trúc trung tâm, nơi hội tụ các quyết định kỹ thuật về quản lý tài nguyên, bảo mật và mô hình ứng dụng. Đây chính là cầu nối giữa hệ điều hành và lập trình viên, đảm bảo Android vừa là một nền tảng mở cho sáng tạo ứng dụng, vừa là một hệ thống được kiểm soát chặt chẽ để duy trì hiệu năng và độ ổn định trên quy mô lớn.

\section{Application Layer}

Application Layer bao gồm toàn bộ các ứng dụng chạy trên Android, từ ứng dụng hệ thống do nhà sản xuất hoặc Google cung cấp cho đến các ứng dụng bên thứ ba được cài đặt bởi người dùng. Về mặt kỹ thuật, không có sự khác biệt cơ bản giữa ứng dụng hệ thống và ứng dụng của bên thứ ba về mô hình thực thi: tất cả đều chạy dựa trên Android Runtime và tương tác với hệ thống thông qua Android Framework. Sự khác biệt chủ yếu nằm ở tập quyền được cấp và mức độ tích hợp với hệ điều hành.

Mỗi ứng dụng Android được triển khai dưới dạng một gói độc lập, chạy trong một tiến trình riêng và có một UID riêng do hệ thống cấp phát. Mô hình này tạo ra sandbox cho từng ứng dụng, đảm bảo rằng lỗi hoặc hành vi bất thường của một ứng dụng không ảnh hưởng trực tiếp đến các ứng dụng khác hay đến hệ thống. Từ góc nhìn bảo mật, đây là lớp phòng vệ đầu tiên ở mức ứng dụng, bổ sung cho các cơ chế bảo vệ ở Linux Kernel và Android Framework.

Ứng dụng không được phép truy cập trực tiếp vào kernel, driver hay phần cứng. Mọi tương tác với hệ thống đều phải thông qua các API chính thức của Android Framework. Điều này có ý nghĩa kỹ thuật quan trọng: Framework trở thành điểm kiểm soát duy nhất, nơi hệ điều hành có thể áp đặt các chính sách về quyền truy cập, quản lý tài nguyên và vòng đời ứng dụng. Nhờ đó, Android có thể duy trì tính ổn định ngay cả khi hệ sinh thái ứng dụng phát triển với tốc độ rất nhanh và không đồng nhất về chất lượng.

Application Layer cũng phản ánh rõ mô hình ứng dụng hướng thành phần của Android. Một ứng dụng không chỉ là một chương trình chạy liên tục, mà là tập hợp các thành phần có thể được hệ thống kích hoạt khi cần thiết. Ví dụ, một activity có thể được tạo ra chỉ để xử lý một tác vụ ngắn, sau đó bị hủy khi không còn cần thiết. Cách tiếp cận này giúp hệ điều hành chủ động quản lý tài nguyên, đặc biệt là bộ nhớ và pin, thay vì để ứng dụng toàn quyền kiểm soát như trên các nền tảng truyền thống.

Từ góc độ khả năng mở rộng, kiến trúc phân tầng mang lại lợi ích rõ rệt cho Application Layer. Khi Android Framework được mở rộng với các API mới, ứng dụng có thể tận dụng các khả năng đó mà không cần quan tâm đến thay đổi ở kernel hay phần cứng. Ngược lại, khi phần cứng thay đổi hoặc được nâng cấp, các ứng dụng hiện có vẫn có thể hoạt động bình thường nhờ HAL và Framework che giấu sự khác biệt. Điều này tạo ra tính ổn định lâu dài cho ứng dụng, một yếu tố then chốt để xây dựng hệ sinh thái phần mềm lớn.

Một ý nghĩa chiến lược khác của Application Layer là khả năng kiểm soát trải nghiệm người dùng ở quy mô lớn. Thông qua các quy định về API, permission và hành vi ứng dụng, Android có thể định hướng cách ứng dụng được thiết kế và vận hành. Điều này giúp giảm thiểu rủi ro từ các ứng dụng kém chất lượng, đồng thời tạo ra một chuẩn chung cho trải nghiệm người dùng trên hàng loạt thiết bị khác nhau.

Tóm lại, Application Layer là nơi kiến trúc Android thể hiện giá trị cuối cùng: cung cấp một nền tảng mở cho phát triển ứng dụng, nhưng vẫn duy trì được mức độ kiểm soát cần thiết để đảm bảo an toàn, hiệu năng và khả năng mở rộng. Chính sự kết hợp chặt chẽ giữa Application Layer và các lớp bên dưới đã giúp Android hình thành một hệ sinh thái ứng dụng rộng lớn, đa dạng và có khả năng phát triển bền vững trong dài hạn.
